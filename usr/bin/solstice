#!/usr/bin/python3

from solstice import main as solstice
from solstice import utils, variables
import os
import sys
import subprocess
import gettext
gettext.install("solstice", "/usr/share/locale", names="ngettext")
import gi
from gi.repository import GLib
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtQml import * #Needs python3-pyqt5.qtquick
from xdg.DesktopEntry import DesktopEntry
import ast
import json
from functools import partial

QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)

storelocation = "/usr/bin/feren-store"
storename = _("toreSay")

#######################################################################################
# Solstice Profile Launcher/Manager                                                   #
#                                                                                     #
# Rest in Peace, Mark Greaves.                                                        #
#######################################################################################

if len(sys.argv) < 2:
    print(_("Usage: solstice desktopfile [options]"))
    sys.exit(1)
if not os.path.isfile(sys.argv[1]):
    print(_("File does not exist."))
    sys.exit(2)

class SolsticeRuntimeException(Exception):
    pass

# Available profiles storage for GUI
class ProfilesModel(QAbstractListModel):
    IDRole = Qt.UserRole + 1
    NameRole = Qt.UserRole + 2

    def __init__(self, parent=None):
        super().__init__(parent)
        self.profiles = []

    def data(self, index, role=Qt.DisplayRole):
        row = index.row()
        if role == self.IDRole:
            return self.profiles[row]["profileid"]
        if role == self.NameRole:
            return self.profiles[row]["pname"]

    def rowCount(self, parent=QModelIndex()):
        return len(self.profiles)

    def roleNames(self):
        return {self.IDRole: b'profileid', self.NameRole: b'pname'}

    def setData(self, data):
        self.profiles = data
        self.layoutChanged.emit()

# Ditto but for the browsers in the browser select
class BrowsersModel(QAbstractListModel):
    IDRole = Qt.UserRole + 1
    NameRole = Qt.UserRole + 2
    IconRole = Qt.UserRole + 3
    DescriptionRole = Qt.UserRole + 4
    AvailableRole = Qt.UserRole + 5
    PrecheckedRole = Qt.UserRole + 6

    def __init__(self, parent=None):
        super().__init__(parent)
        self.browsers = []

    def data(self, index, role=Qt.DisplayRole):
        row = index.row()
        if role == self.IDRole:
            return self.browsers[row]["browserid"]
        if role == self.NameRole:
            return self.browsers[row]["brname"]
        if role == self.IconRole:
            return self.browsers[row]["bricon"]
        if role == self.DescriptionRole:
            return self.browsers[row]["desc"]
        if role == self.AvailableRole:
            return self.browsers[row]["available"]
        if role == self.PrecheckedRole: #For preselecting current choice
            return self.browsers[row]["prechecked"]

    def rowCount(self, parent=QModelIndex()):
        return len(self.browsers)

    def roleNames(self):
        return {self.IDRole: b'browserid', self.NameRole: b'brname',
            self.IconRole: b'bricon', self.DescriptionRole: b'desc',
            self.AvailableRole: b'available', self.PrecheckedRole: b'prechecked'}

    def setData(self, data):
        self.browsers = data
        self.layoutChanged.emit()


class SolsticeErrorWnd():
    def __init__(self, wmclass, hasstore=None, canedit=None, amadmin=None, inapp=False, engine=None):
        if inapp == False:
            self.app = QApplication(sys.argv)
            self.app.setDesktopFileName(wmclass)
            self.app.setApplicationName(wmclass)
            self.eng = QQmlApplicationEngine()
            self.eng.quit.connect(self.app.quit)
        else:
            self.eng = engine

        # Load condition-variables
        if hasstore == None:
            self.hasstore = storelocation and os.path.isfile(storelocation)
        else:
            self.hasstore = hasstore
        self.eng.rootContext().setContextProperty('storeAvailable', hasstore)
        if canedit == None:
            self.canedit = os.access(sys.argv[1], os.W_OK)
        else:
            self.canedit = canedit
        self.eng.rootContext().setContextProperty('canEdit', canedit)
        if amadmin == None:
            self.amadmin = utils.amAdministrator()
        else:
            self.amadmin = amadmin
        self.eng.rootContext().setContextProperty('amAdmin', amadmin)

        #Load QML
        self.eng.load('/usr/lib/solstice/guierror.qml')
        self.wnd = self.eng.rootObjects()[0]
        #Connect main window events
        self.wnd.dismiss.connect(self.wnd.close)
        self.wnd.openStoreBrowsers.connect(self.wnd.close) #TODO
        self.wnd.openStoreID.connect(self.wnd.close) #TODO
        #Set label values
        self.labels()

    def exec(self): #Allows pre-app error-dialogs
        return self.app.exec()

    def labels(self):
        self.wnd.findChild(QObject, "moreInformationBtn").setProperty("text", _("More information"))
        self.wnd.findChild(QObject, "getStoreBrowsersBtn").setProperty("text", _("Get a new browser from %s...") % storename + " (dummy)") #TODO
        self.wnd.findChild(QObject, "genericOk").setProperty("text", _("Ok"))
        self.wnd.findChild(QObject, "unavailableOk").setProperty("text", _("Ok"))
        self.wnd.findChild(QObject, "unavailableDismiss").setProperty("text", _("Dismiss"))
        self.wnd.findChild(QObject, "uninstallStoreBtn").setProperty("text", _("Remove...") + " (dummy)") #TODO


    def SolsticeError(self, errortitle, errorheader, errortext):
        self.wnd.findChild(QObject, "genericError").setProperty('visible', True)

        #Change labels
        self.wnd.setProperty('title', errortitle)
        self.wnd.findChild(QObject, "genericErrorHeader").setProperty("text", errorheader)
        self.wnd.findChild(QObject, "genericErrorSubheader").setProperty("text", errortext)


    def SolsticeWebsiteGoneError(self, appname, announcement):
        self.wnd.findChild(QObject, "unavailableError").setProperty('visible', True)
        #Connect More Information button
        self.wnd.unavailMoreInformation.connect(partial(subprocess.run, ["/usr/bin/xdg-open", announcement]))

        #Change labels
        self.wnd.setProperty('title', appname)
        self.wnd.findChild(QObject, "unavailableHeader").setProperty("text", _("%s is no longer available") % appname)
        self.wnd.findChild(QObject, "unavailableSubheader").setProperty("text", _("Unfortunately, %s has been closed down, meaning it is no longer available.\n\nSince %s is no longer available, would you like to remove it?\nNOTE: Once done, you cannot install %s again.") % (appname, appname, appname))

        #Special conditions for when unable to manage the file
        if self.canedit == False and self.amadmin == False:
            self.wnd.findChild(QObject, "unavailableSubheader").setProperty("text", _("Unfortunately, %s has been closed down, meaning it is no longer available.\n\nPlease contact an administrator to remove %s.") % (appname, appname))


    def SolsticeBrowserTypeUnavailableError(self, appname):
        self.wnd.findChild(QObject, "unavailableError").setProperty('visible', True)
        self.wnd.findChild(QObject, "moreInformationBtn").setProperty('visible', False)

        #Change labels
        self.wnd.setProperty('title', _("No browsers available - %s") % appname)
        self.wnd.findChild(QObject, "unavailableHeader").setProperty("text", _("No browsers are available for %s") % appname)
        self.wnd.findChild(QObject, "unavailableSubheader").setProperty("text", _("%s cannot start as there are no longer any browsers available that can run it.\n\nYou will need to remove, then re-install, %s to continue using it.") % (appname, appname))

        #Special conditions for when unable to manage the file
        if self.canedit == False and self.amadmin == False:
            self.wnd.findChild(QObject, "unavailableSubheader").setProperty("text", _("%s cannot start as there are no longer any browsers available that can run it.\n\nAn administrator needs to remove, then re-install, %s before you can continue using it.") % (appname, appname))


    def SolsticeNoBrowserError(self, appname, browser, browsertype):
        self.wnd.findChild(QObject, "noBrowsersError").setProperty('visible', True)

        #Change labels
        self.wnd.setProperty('title', _("No browsers available - %s") % appname)
        self.wnd.findChild(QObject, "noBrowsersHeader").setProperty("text", _("No browsers are available for %s") % appname)
        self.wnd.findChild(QObject, "noBrowsersSubheader").setProperty("text", _("%s cannot currently start as there are no installed browsers that can run it.") % appname)
        if "unavailable" in variables.sources[browsertype][browser]:
            self.wnd.findChild(QObject, "browserSubstituteTitle").setProperty("text", _("%s can no longer run %s") % (variables.sources[browsertype][browser]["name"], appname))
            if variables.sources[browsertype][browser]["unavailable"] == 0: #Changed browsertype
                self.wnd.findChild(QObject, "browserSubstituteDesc").setProperty("text", _("The browser used to launch %s has changed browser engines, and is no longer compatible with its profiles.") % appname)
            elif variables.sources[browsertype][browser]["unavailable"] == 1: #No longer supported
                self.wnd.findChild(QObject, "browserSubstituteDesc").setProperty("text", _("The browser used to launch %s is no longer compatible.") % appname)
            self.wnd.findChild(QObject, "getStoreBrowserBtn").setProperty('visible', False)
        else:
            self.wnd.findChild(QObject, "browserSubstituteTitle").setProperty("text", _("%s was chosen for %s") % (variables.sources[browsertype][browser]["name"], appname))
            self.wnd.findChild(QObject, "browserSubstituteDesc").setProperty("text", _("Would you like to install {0} to allow {1} to run?").format(variables.sources[browsertype][browser]["name"], appname))
            self.wnd.findChild(QObject, "getStoreBrowserBtn").setProperty("text", _("View %s in %s... (dummy)") % (variables.sources[browsertype][browser]["name"], storename))
            self.wnd.findChild(QObject, "getStoreBrowserBtn").setProperty('visible', 'storeAvailable')

        #Special conditions for when unable to manage the file
        if self.canedit == False:
            self.wnd.setProperty('title', _("Browser unavailable - %s") % appname)
            self.wnd.findChild(QObject, "noBrowsersHeader").setProperty("text", _("The browser for %s is unavailable") % appname)
            self.wnd.findChild(QObject, "noBrowsersSubheader").setProperty("text", _("%s cannot currently start as its chosen browser is currently unavailable.") % appname)



class SolsticeDFileException(Exception):
    pass
class SolsticeOutdatedException(Exception):
    pass
class ApplicationInfo():
    def __init__(self, desktopfile):
        self.app = {}
        self.parent = {}
        self.parentfile = None

        #Open the main .desktop file
        info = DesktopEntry()
        try:
            info.parse(desktopfile)
        except Exception as e:
            raise SolsticeDFileException(e)

        #Ensure this shortcut is new enough for this version of Solstice
        # NOTE: Increasing this value should only be done under emergency circumstances.
        if info.get("X-Solstice-Version") == "":
            raise SolsticeOutdatedException()
        elif int(info.get("X-Solstice-Version")) < 1:
            raise SolsticeOutdatedException()

        #Is this file a child application?
        try:
            parentid = info.get("X-Solstice-ParentID")
            if parentid != '':
                self.parentfile = utils.getParentShortcut(parentid, info.getStartupWMClass(), info.get("X-Solstice-ID"), sys.argv[1])
                parentinfo = DesktopEntry()
                parentinfo.parse(self.parentfile)
                #Get parent information for profile updating usage
                self.parent = self.getParentInformation(parentinfo)
            else:
                self.parent = self.getParentInformation(info)

            #Get information for the Solstice GUI
            self.app["name"] = info.getName()
            self.app["wmclass"] = info.getStartupWMClass()
            self.app["website"] = info.get("X-Solstice-Website")
        except Exception as e:
            raise SolsticeDFileException(e)


    def verifySetting(self, getvalue, intendedtype, valueid, fallback=None):
        if getvalue == "": #Not found
            if fallback == None:
                raise SolsticeDFileException(_("%s required but not found") % valueid)
            else:
                print(_("W: %s was not found - using fallback value") % valueid)
                return fallback
        #Convert to correct typing
        try:
            if intendedtype == list or intendedtype == dict:
                getvalue = ast.literal_eval(getvalue)
            elif intendedtype == bool:
                getvalue = self.strToBool(getvalue)
            elif intendedtype == int:
                getvalue = int(getvalue)
            if type(getvalue) != intendedtype:
                raise SolsticeDFileException
        except:
            if fallback == None:
                raise SolsticeDFileException(_("%s has an invalid value") % valueid)
            else:
                print(_("W: %s has an invalid value - using fallback value") % valueid)
                return fallback
        #All checks have passed
        return getvalue

    def getParentInformation(self, entry):
        result = {}
        # Base information
        result["name"] = self.verifySetting(entry.getName(), str, "Name")
        result["wmclass"] = self.verifySetting(entry.getStartupWMClass(), str, "Window Class")
        result["website"] = self.verifySetting(entry.get("X-Solstice-Website"), str, "Website")
        result["browser"] = self.verifySetting(entry.get("X-Solstice-Browser"), str, "Selected Browser")
        result["browsertype"] = self.verifySetting(entry.get("X-Solstice-BrowserType"), str, "browsertype")
        result["id"] = self.verifySetting(entry.get("X-Solstice-ID"), str, "Shortcut ID")
        result["childids"] = self.verifySetting(entry.get("X-Solstice-Children"), list, "Childrens' IDs")
        result["childwebsites"] = self.verifySetting(entry.get("X-Solstice-ChildWebsites"), list, "Child websites")
        result["lastupdated"] = self.verifySetting(entry.get("X-Solstice-LastUpdate"), int, "lastupdated")
        # Enables the Store shortcut
        result["storeid"] = entry.get("X-Solstice-StoreID")
        # Application Features
        result["services"] = self.verifySetting(entry.get("X-Solstice-Services"), list, "Required services", [])
        result["nohistory"] = self.verifySetting(entry.get("X-Solstice-NoHistory"), bool, "Disable history", False)
        result["workspaces"] = self.verifySetting(entry.get("X-Solstice-Workspaces"), bool, "Enable Workspaces", False)
        # Your Preferences
        result["bonusids"] = self.verifySetting(entry.get("X-Solstice-BonusIDs"), list, "Bonuses", [])
        # Colour Palette
        result["accent"] = self.verifySetting(entry.get("X-Solstice-Accent"), str, "Accent Colour")
        result["accentdark"] = self.verifySetting(entry.get("X-Solstice-Accent-Dark"), str, "Accent Colour (Dark)", result["accent"])
        # Colour Palette - Connected Tabs
        result["connheaderlight"] = self.verifySetting(entry.get("X-Solstice-ConnectedHeader"), str, "Header background (Connected Tabs)")
        result["connheaderdark"] = self.verifySetting(entry.get("X-Solstice-ConnectedHeader-Dark"), str, "Header background (Connected Tabs, Dark)", result["connheaderlight"])
        result["conntablight"] = self.verifySetting(entry.get("X-Solstice-ConnectedTab"), str, "Tab background (Connected Tabs)")
        result["conntabdark"] = self.verifySetting(entry.get("X-Solstice-ConnectedTab-Dark"), str, "Tab background (Connected Tabs, Dark)", result["conntablight"])
        result["connsitelight"] = self.verifySetting(entry.get("X-Solstice-ConnectedSite"), str, "Page background (Connected Tabs)")
        result["connsitedark"] = self.verifySetting(entry.get("X-Solstice-ConnectedSite-Dark"), str, "Page background (Connected Tabs, Dark)", result["connsitelight"])
        # Colour Palette - Floating Tabs
        result["headerlight"] = self.verifySetting(entry.get("X-Solstice-Header"), str, "Header background")
        result["headerdark"] = self.verifySetting(entry.get("X-Solstice-Header-Dark"), str, "Header background (Dark)", result["headerlight"])
        result["tablight"] = self.verifySetting(entry.get("X-Solstice-Tab"), str, "Tab background")
        result["tabdark"] = self.verifySetting(entry.get("X-Solstice-Tab-Dark"), str, "Tab background (Dark)", result["tablight"])
        result["sitelight"] = self.verifySetting(entry.get("X-Solstice-Site"), str, "Page background")
        result["sitedark"] = self.verifySetting(entry.get("X-Solstice-Site-Dark"), str, "Page background (Dark)", result["sitelight"])
        result["tabhasshadow"] = self.verifySetting(entry.get("X-Solstice-Tab-Shadow"), bool, "Floating tabs shadows", True)
        return result

    def strToBool(self, string):
        if string == "true":
            return True
        else:
            return False


class SolsticeApp(QApplication):
    def __init__(self, wmclass, info, profilesdir, browseravailable, configs, autoload):
        super().__init__(sys.argv)

        # Load essential pre-autoload variables
        self.info = info
        self.profilesdir = profilesdir
        self.configs = configs
        self.autoload = autoload

        # Automatically load the profile if conditions are met
        if "--force-manager" not in sys.argv and autoload != None and browseravailable == True:
            if self.openProfile(autoload, True, True) == True:
                sys.exit(0)

        # Initialise QML Engines, and ensure the application actually exits upon their closure
        self.eng = QQmlApplicationEngine()
        self.eng.quit.connect(self.quit)

        self.setDesktopFileName(wmclass)
        self.setApplicationName(wmclass)

        # Load variables
        self.hasstore = os.path.isfile(storelocation)
        self.eng.rootContext().setContextProperty('storeAvailable', self.hasstore)
        self.canedit = os.access(sys.argv[1], os.W_OK)
        self.eng.rootContext().setContextProperty('canEdit', self.canedit)
        self.amadmin = utils.amAdministrator()
        self.eng.rootContext().setContextProperty('amAdmin', self.amadmin)
        self.eng.rootContext().setContextProperty('fromStore', "storeid" in self.info.parent and self.info.parent["storeid"])
        self.eng.rootContext().setContextProperty('bonusesAvailable', False)

        # Initialise models
        self.browsersmodel = BrowsersModel()
        self.eng.rootContext().setContextProperty('BrowsersModel', self.browsersmodel)
        self.profilesmodel = ProfilesModel()
        self.eng.rootContext().setContextProperty('ProfilesModel', self.profilesmodel)

        # Load QML
        self.eng.load('/usr/lib/solstice/gui.qml')
        self.wnd = self.eng.rootObjects()[0]
        # Connect main window events
        self.wnd.openProfile.connect(self.openProfile)
        self.wnd.newProfile.connect(self.newProfile)
        self.wnd.manageProfile.connect(self.manageProfile)
        self.wnd.saveProfile.connect(self.saveProfile)
        self.wnd.deleteProfile.connect(self.deleteProfile)
        self.wnd.gotoBrowserSelect.connect(self.browserSelect)
        self.wnd.setBrowser.connect(self.setBrowser)

        # Set label values, and the window title
        self.labels()

        # If the browser is unavailable, enter browser select
        if not browseravailable:
            self.browserSelect(True)
            return
        
        # Set browser-available-only variables/labels
        if utils.browserFeatureAvailable(self.info.parent["browsertype"], self.info.parent["browser"], "bonusesavailable"):
            self.eng.rootContext().setContextProperty('bonusesAvailable', "storeid" in self.info.app)
        if utils.browserFeatureAvailable(self.info.parent["browsertype"], self.info.parent["browser"], "nocacheavailable"):
            self.wnd.findChild(QObject, "noCacheHint").setProperty("text", _("Worsens load times of websites"))
        else:
            self.wnd.findChild(QObject, "noCache").setProperty('enabled', False)
            self.wnd.findChild(QObject, "noCacheHint").setProperty("text", _("Not available on %s") % \
                utils.getTranslation(variables.sources[self.info.parent["browsertype"]][self.info.parent["browser"]]["name"]))

        # Otherwise, load profile select:
        self.loadUserModel()
        self.editedprof = None
        self.editrname = None # Used in profile editor
        self.editnocache = None

    def labels(self):
        self.wnd.setProperty('title', self.info.app["name"])
        self.wnd.findChild(QObject, "profilesHeader").setProperty("text", _("Who's using %s?") % self.info.app["name"])
        self.wnd.findChild(QObject, "profilesSubheader").setProperty("text", _("Select your profile from the options below to begin.\nIf you are a new user, press "+'"'+"Add a profile"+'"'+" instead to begin."))
        self.wnd.findChild(QObject, "alwaysUseProfile").setProperty("text", _("Always use this profile"))
        self.wnd.findChild(QObject, "alwaysUseProfileHint").setProperty("text", _('You can manage profiles and select other profiles by right-clicking this application in the Applications Menu and choosing "Manage profiles".'))
        self.wnd.findChild(QObject, "manageHeader").setProperty("text", _("Manage %s Profiles") % self.info.app["name"])
        self.wnd.findChild(QObject, "manageSubheader").setProperty("text", _("Select a profile from the options below to manage it.\nOnce you are done managing profiles, press Done below."))
        #editProfileHeader is changed when visiting the page
        self.wnd.findChild(QObject, "editProfileSubheader").setProperty("text", _("Choose your name, and options for your profile.\nOnce you are done. press Finish below."))
        self.wnd.findChild(QObject, "editProfileNameHint").setProperty("text", _("Profile name"))
        self.wnd.findChild(QObject, "noCache").setProperty("text", _("Disable browser cache"))
        #noCacheHint is changed later
        self.wnd.findChild(QObject, "browsersHeader").setProperty("text", _("Choose a browser to launch %s") % self.info.app["name"])
        #browsersSubheader is changed by gotoBrowserSelect
        self.wnd.findChild(QObject, "manageBonusesBtn").setProperty("text", _("Manage bonuses in %s...") % storename + " (dummy)") #TODO
        self.wnd.findChild(QObject, "changeBrowserBtn").setProperty("text", _("Change browser..."))
        self.wnd.findChild(QObject, "editorCancelBtn").setProperty("text", _("Cancel"))
        self.wnd.findChild(QObject, "deleteProfileBtn").setProperty("text", _("Delete profile"))
        self.wnd.findChild(QObject, "cancelBrowserSelect").setProperty("text", _("Cancel"))
        self.wnd.findChild(QObject, "storeBrowsersBtn").setProperty("text", _("Get a new browser from %s...") % storename + " (dummy)") #TODO
        self.wnd.findChild(QObject, "browserSelectDone").setProperty("text", _("Done"))
        self.wnd.findChild(QObject, "profileSelectAdd").setProperty("text", _("Add a profile..."))
        self.wnd.findChild(QObject, "gotoManagerBtn").setProperty("text", _("Manage profiles..."))
        self.wnd.findChild(QObject, "exitManagerBtn").setProperty("text", _("Done"))
        self.wnd.findChild(QObject, "editorDoneBtn").setProperty("text", _("Finish"))

    def showError(self):
        self.eeng = QQmlApplicationEngine()
        self.eeng.quit.connect(self.quit)
        return SolsticeErrorWnd(self.info.app["wmclass"], self.hasstore, self.canedit, self.amadmin, True, self.eeng)


    #Browser Management
    def browserSelect(self, force=False):
        if not os.path.isfile(sys.argv[1]):
            sys.exit(3)

        #Shortened for cleaner code
        browser = self.info.parent["browser"]
        browsertype = self.info.parent["browsertype"]

        # Get available browser options
        installed, available = utils.getAvailableBrowsers(browsertype)
        # Show an error if there are no browsers available for this application
        if available == 0:
            error = self.showError()
            error.SolsticeBrowserTypeUnavailableError(self.info.app["name"])
            self.wnd.close()
            sys.exit(error.exec())
        # Show an error if there are no available browsers installed
        if installed == 0:
            error = self.showError()
            error.SolsticeNoBrowserError(self.info.app["name"], browser, browsertype)
            self.wnd.close()

        browsers = []
        for i in variables.sources[browsertype]:
            if "unavailable" in variables.sources[browsertype][i]:
                continue #Don't show unavailable browsers
            if not utils.isBrowserAvailable(i, browsertype):
                continue #Don't show uninstalled browsers

            browserhas = []
            descs = {"extensionprotection": _("additional security features"),
                     "websiteperms": _("website-specific personalisations"),
                     "followspalette": _("follows the application's palette")}
            for ii in descs:
                if ii in variables.sources[browsertype][i]:
                    if variables.sources[browsertype][i][ii] == True:
                        browserhas.append(ii)

            #Conditional subtitles
            if "extensionprotection" in browserhas and "websiteperms" in browserhas and "followspalette" in browserhas:
                browserdesc = _("Recommended browser - allows additional security features and website-specific personalisations, and follows the application's palette")
            elif browserhas == []:
                browserdesc = ""
            else:
                browserdesc = ""
                for ii in browserhas:
                    if browserdesc == "":
                        if ii != "followspalette":
                            browserdesc = _("Allows %s") % descs[ii]
                        else:
                            browserdesc = descs[ii].capitalize()
                    elif ii == browserhas[-1]:
                        browserdesc = _("%s, and %s") % (browserdesc, descs[ii])
                    else:
                        browserdesc = _("%s, %s") % (browserdesc, descs[ii])

            #Append to list of browsers
            browsers.append({"browserid": i,
                "brname": utils.getTranslation(variables.sources[browsertype][i]["name"]),
                "bricon": variables.sources[browsertype][i]["icon"],
                "desc": browserdesc,
                "available": True,
                "prechecked": i == browser})

        for i in variables.sources:
            if i == browsertype:
                continue
            for ii in variables.sources[i]:
                if "unavailable" in variables.sources[i][ii]:
                    continue
                if not utils.isBrowserAvailable(ii, i):
                    continue

                #Append to list of browsers
                browsers.append({"browserid": ii,
                    "brname": utils.getTranslation(variables.sources[i][ii]["name"]),
                    "bricon": variables.sources[i][ii]["icon"],
                    "desc": _("Not available - Website Applications made on non-%s browsers cannot use %s as their browser") % (
                        i.capitalize(),
                        utils.getTranslation(variables.sources[i][ii]["name"])),
                    "available": False,
                    "prechecked": False})

        #Refresh browsers list in browsersmodel
        self.browsersmodel.setData(browsers)

        #Switch pages to browser select
        if force == True:
            self.wnd.findChild(QObject, "cancelBrowserSelect").setProperty('enabled', False) #Disable cancel button
            self.wnd.findChild(QObject, "browsersSubheader").setProperty("text", _("The browser used to launch this application is missing or has been removed.\nTo continue, please choose a replacement browser below."))
            if "unavailable" in variables.sources[browsertype][browser]: #Check if unavailable
                if variables.sources[browsertype][browser]["unavailable"] == 0: #Changed browsertype
                    self.wnd.findChild(QObject, "browsersSubheader").setProperty("text", _("The browser used to launch this application has changed browser engines, and is no longer compatible with %s's profiles.\nTo continue, please choose a replacement browser below.") % self.info.parent["name"])
                elif variables.sources[browsertype][browser]["unavailable"] == 1: #No longer supported
                    self.wnd.findChild(QObject, "browsersSubheader").setProperty("text", _("The browser used to launch this application is no longer compatible.\nTo continue, please choose a replacement browser below."))
        else: #Visiting the browser changer manually
            self.wnd.findChild(QObject, "browsersSubheader").setProperty("text", _("Select a browser from the options below to use it for this application.\nIf you want to keep your current preference, press Cancel."))
            self.wnd.findChild(QObject, "cancelBrowserSelect").setProperty('enabled', True)
        self.wnd.findChild(QObject, "pages").setProperty('currentIndex', 3)


    def setBrowser(self, newbrowser):
        #Edit the .desktop file, and rename it if necessary
        if self.info.parentfile != None:
            newlocation = utils.changeBrowserValue(self.info.parentfile, self.info.parent["browsertype"], self.info.parent["browser"], newbrowser, sys.argv[1])
        else:
            newlocation = utils.changeBrowserValue(sys.argv[1], self.info.parent["browsertype"], self.info.parent["browser"], newbrowser)

        #Relaunch with new .desktop file, and exit this instance
        commandtorun = list(sys.argv)
        commandtorun[1] = newlocation
        subprocess.Popen(commandtorun)
        self.quit()


    #User Management
    def loadUserModel(self):
        if not os.path.isfile(sys.argv[1]) or not os.path.isdir(self.profilesdir):
            sys.exit(3) #It will regenerate on the next run.

        profiles = []
        for i in os.listdir(self.profilesdir):
            if os.path.isdir(self.profilesdir + "/" + i):
                readablename = i
                if os.path.isfile("%s/%s/.solstice-settings" % (self.profilesdir, i)):
                    with open("%s/%s/.solstice-settings" % (self.profilesdir, i), 'r') as fp:
                        solsettings = json.loads(fp.read())
                        if "readablename" in solsettings:
                            readablename = solsettings["readablename"]
                profiles.append({"pname": readablename, "profileid": i})

        #Refresh profiles list in profilesmodel
        self.profilesmodel.setData(profiles)
        if len(profiles) == 1 and self.autoload != None:
            self.wnd.findChild(QObject, "alwaysUseProfile").setProperty("checked", True)
        elif profiles == []:
            self.newProfile(True)


    def openProfile(self, profileid, autoload, autoloaded=False):
        if not os.path.isfile(sys.argv[1]):
            sys.exit(3)

        #Start the requested profile
        try:
            solstice.runProfile(self.info.parent, self.info.app, self.configs, self.profilesdir, profileid, self.closecall)
        except Exception as e:
            if autoloaded == True:
                return False
            else:
                error = self.showError()
                error.SolsticeError(_("Failed to load profile - %s") % self.info.app["name"], _("Failed to load profile"), _("An error occurred while attempting to load this profile:\n%s\n\nPlease check Solstice is up to date, and if so report this error to your Solstice distributor.") % e)
                self.wnd.close()
                return False

        #Set autoload if autoload is True
        if autoloaded == False: #Don't change autoload if autoloading
            if (autoload == True and self.autoload == profileid) \
                or (autoload == False and self.autoload == None): #Prevent file-write-redundancy
                self.quit()
                return True

            with open("%s/.solstice-settings" % self.profilesdir, 'r') as fp:
                configs = json.loads(fp.read())
            if autoload == True:
                configs["autoload"] = profileid
            else:
                configs.pop("autoload", None)

            try:
                with open("%s/.solstice-settings" % self.profilesdir, 'w') as fp:
                    fp.write(json.dumps(configs, separators=(',', ':')))
            except Exception as e:
                print(_("W: Could not change autostart preference: %s") % e) #Warn in output, but continue

        self.quit()
        return True

    def closecall(self):
        try:
            self.wnd.close()
        except:
            pass #Autoload doesn't have wnd, so will always fail without try.


    def newProfile(self, forced=False):
        if not os.path.isfile(sys.argv[1]):
            self.quit() #Exit if uninstalled
            return
        
        self.editedprof, self.editrname, self.editnocache = None, None, None

        self.wnd.findChild(QObject, "editProfileNameError").setProperty("text", "")
        self.wnd.findChild(QObject, "editProfileHeader").setProperty("text", _("Create a profile for %s") % self.info.app["name"])
        self.wnd.findChild(QObject, "editProfileName").setProperty("text", "")
        self.wnd.findChild(QObject, "noCache").setProperty("checked", False)

        self.wnd.findChild(QObject, "deleteProfileBtn").setProperty('enabled', False)
        self.wnd.findChild(QObject, "pages").setProperty('currentIndex', 2)
        self.wnd.findChild(QObject, "editProfileName").forceActiveFocus(True)

    def manageProfile(self, profileid):
        if not os.path.isfile(sys.argv[1]):
            self.quit()
            return
        
        self.editedprof = profileid
        self.editrname, self.editnocache = utils.getProfileSettings(self.profilesdir, profileid)

        self.wnd.findChild(QObject, "editProfileNameError").setProperty("text", "")
        self.wnd.findChild(QObject, "editProfileHeader").setProperty("text", _("Configure %s") % self.editrname)
        self.wnd.findChild(QObject, "editProfileName").setProperty("text", self.editrname)
        if self.wnd.findChild(QObject, "noCache").property("enabled"):
            self.wnd.findChild(QObject, "noCache").setProperty("checked", self.editnocache)

        self.wnd.findChild(QObject, "deleteProfileBtn").setProperty('enabled', True)
        self.wnd.findChild(QObject, "pages").setProperty('currentIndex', 2)
        self.wnd.findChild(QObject, "editProfileName").forceActiveFocus(True)


    def saveProfile(self):
        if not os.path.isfile(sys.argv[1]):
            self.quit()
            return
        
        newname = self.wnd.findChild(QObject, "editProfileName").property("text")
        if newname == "":
            self.wnd.findChild(QObject, "editProfileNameError").setProperty("text", _("Please enter a name for this profile"))
            return
        nocache = self.wnd.findChild(QObject, "noCache").property("checked")

        try:
            if self.editedprof == None: # New profile
                profileid = utils.generateProfileID(self.profilesdir, newname)
                profiledir = self.profilesdir + "/" + profileid

                # Create the profile's folder and generate initial configurations
                os.mkdir(profiledir)
                psettings = {"readablename": newname, "nocache": nocache}
                with open("%s/.solstice-settings" % profiledir, 'w') as fp:
                    fp.write(json.dumps(psettings, separators=(',', ':')))
                # 'Update' the newly generated profile and its CSS
                solstice.updateCSS(self.info.parent, profiledir)
                solstice.updateProfile(self.info.parent, self.configs, psettings, profiledir)
            else: # Existing profile
                profiledir = self.profilesdir + "/" + self.editedprof

                # Check profile isn't running
                running = solstice.profileInUse(profiledir)

                # Set new settings
                if newname != self.editrname:
                    solstice.setProfileName(self.info.parent, newname, profiledir, running)
                if nocache != self.editnocache:
                    solstice.setNoCache(self.info.parent, nocache, profiledir, running)

                if running == True and (newname != self.editrname or nocache != self.editnocache):
                    # Force the profile to be updated on next launch
                    psettings = {}
                    if os.path.isfile("%s/.solstice-settings" % profiledir):
                        with open("%s/.solstice-settings" % profiledir, 'r') as fp:
                            psettings = json.loads(fp.read())

                    psettings.pop("solstlastupdated")

                    with open("%s/.solstice-settings" % profiledir, 'w') as fp:
                        fp.write(json.dumps(psettings, separators=(',', ':')))
        except Exception as e:
            self.wnd.findChild(QObject, "editProfileNameError").setProperty('text', _("Failed to save changes"))
            print(_("Failed to save changes: %s") % e)
            return

        if self.editedprof == None:
            # Automatically open the new profile
            self.openProfile(profileid, False)
        else:
            # Refresh profiles list and return to profiles manager
            self.loadUserModel()
            if (len(self.profilesmodel.profiles) > 0):
                self.wnd.findChild(QObject, "pages").setProperty('currentIndex', 1)
                self.wnd.findChild(QObject, "profileSelect").forceActiveFocus(True)


    def deleteProfile(self):
        utils.deleteProfile(self.profilesdir + "/" + self.editedprof)

        self.loadUserModel()
        if (len(self.profilesmodel.profiles) > 0):
            self.wnd.findChild(QObject, "pages").setProperty('currentIndex', 1)
            self.wnd.findChild(QObject, "profileSelect").forceActiveFocus(True)


class SolsticeInit():
    def __init__(self):
        # Get the required information
        try:
            self.info = ApplicationInfo(sys.argv[1])
        except Exception as e:
            error = SolsticeErrorWnd("solstice")
            if e.__class__.__name__ == "SolsticeDFileException":
                print(_("Corrupt or incompatible file: %s") % e)
                error.SolsticeError(_("Incompatible file - Solstice"), _("Corrupt or incompatible file"), _("The application you attempted to open is either corrupt or is too new for this version of Solstice.\n\nPlease reinstall or update this application, or update Solstice."))
            elif e.__class__.__name__ == "SolsticeOutdatedException":
                error.SolsticeError(_("Update required - Solstice"), _("This application needs to be updated"), _("The application you attempted to open was made for an older version of Solstice, and is no longer compatible with this version of Solstice.\n\nPlease update this application to continue using it."))
            else:
                error.SolsticeError(_("Failed to load application - Solstice"), _("Failed to load application"), _("An error occurred when attempting to load this application:\n%s\n\nPlease reinstall or update this application, or try reinstalling Solstice.") % e)
            sys.exit(error.exec())

        # Check the browser is valid
        if self.info.parent["browsertype"] not in variables.sources or self.info.parent["browser"] not in variables.sources[self.info.parent["browsertype"]]:
            print(_("Corrupt or incompatible file: %s") % _("Browser is invalid"))
            error = SolsticeErrorWnd(self.info.app["wmclass"])
            error.SolsticeError(_("Incompatible file - Solstice"), _("Corrupt or incompatible file"), _("The application you attempted to open is either corrupt or is too new for this version of Solstice.\n\nPlease reinstall or update this application, or update Solstice."))
            sys.exit(error.exec())

        # Check the website is even available
        if utils.shortenURL(self.info.app["website"]) in variables.unavailable:
            url = utils.shortenURL(self.info.app["website"])
            error = SolsticeErrorWnd(self.info.app["wmclass"])
            error.SolsticeWebsiteGoneError(self.info.app["name"], variables.unavailable[url]["announcement"])
            sys.exit(error.exec())

        # Check the browser is installed
        browseravailable = utils.isBrowserAvailable(self.info.parent["browser"], self.info.parent["browsertype"])
        if browseravailable == False:
            installed, available = utils.getAvailableBrowsers(self.info.parent["browsertype"])
            #Show an error if there are no browsers available for this application
            if available == 0:
                error = SolsticeErrorWnd(self.info.app["wmclass"])
                error.SolsticeBrowserTypeUnavailableError(self.info.app["name"])
                sys.exit(error.exec())
            #Show an error if the shortcut is read-only or there are no available browsers installed
            if os.access(sys.argv[1], os.W_OK) == False or installed == 0:
                error = SolsticeErrorWnd(self.info.app["wmclass"])
                error.SolsticeNoBrowserError(self.info.app["name"], self.info.parent["browser"], self.info.parent["browsertype"])
                sys.exit(error.exec())

        # All checks passed, commence initialisation
        self.profilesdir = "{0}/{1}".format(variables.solsticeProfilesDirectory, self.info.parent["id"])

        # If browser isn't available, launch the GUI in browser picker mode
        if browseravailable != True:
            # Load settings for this application, without granting permissions if missing
            configs = self.loadMainSettings(True)

            # Start the GUI to the browser switcher interface
            app = SolsticeApp(self.info.app["wmclass"], self.info, self.profilesdir, browseravailable, configs, None)
        else:
            # Load settings for this application
            configs = self.loadMainSettings()

            # Get automatic load profile
            autoload = self.getAutoload(configs)

            #Start the GUI with the collated settings
            app = SolsticeApp(self.info.app["wmclass"], self.info, self.profilesdir, browseravailable, configs, autoload)
        sys.exit(app.exec())


    def loadMainSettings(self, noperms=False):
        # Check the settings exist - if not, generate them
        if not os.path.isdir(self.profilesdir):
            os.mkdir(self.profilesdir)
        if not os.path.isfile("%s/.solstice-settings" % self.profilesdir):
            return self.updateMainSettings({}, noperms)

        # Load and update any settings needing updating
        with open("%s/.solstice-settings" % self.profilesdir, 'r') as fp:
            configs = json.loads(fp.read())
        return self.updateMainSettings(configs, noperms)
    

    def updateMainSettings(self, configs, noperms):
        changesmade = False
        newflatpak = None
        if "flatpak" in variables.sources[self.info.parent["browsertype"]][self.info.parent["browser"]]:
            newflatpak = variables.sources[self.info.parent["browsertype"]][self.info.parent["browser"]]["flatpak"]
        # Remove Flatpak permissions if Flatpak changed
        if "lastflatpak" in configs:
            if configs["lastflatpak"] != newflatpak:
                utils.removeFlatpakProfilesPerm(configs["lastflatpak"], self.profilesdir)
                if "lastdownloadsdir" in configs and "downloadsdirname" in configs:
                    utils.removeFlatpakDownloadsPerm(configs["lastflatpak"], configs["lastdownloadsdir"], configs["downloadsdirname"])
                configs.pop("lastflatpak", None)
                changesmade = True

        # Disassociate the Downloads folder if the folder locale changed
        newdownloadsdir = GLib.get_user_special_dir(GLib.UserDirectory.DIRECTORY_DOWNLOAD)
        if "lastdownloadsdir" in configs:
            if configs["lastdownloadsdir"] != newdownloadsdir:
                if "lastflatpak" in configs and "downloadsdirname" in configs:
                    utils.removeFlatpakDownloadsPerm(configs["lastflatpak"], configs["lastdownloadsdir"], configs["downloadsdirname"])
                configs.pop("lastdownloadsdir", None)
                changesmade = True

        # Assign permanent name for the specific Downloads folder if first launch
        if "downloadsdirname" not in configs:
            configs["downloadsdirname"] = _("%s Downloads") % self.info.parent["name"]
            changesmade = True

        # Associate new Downloads folder if disassociated or first launch
        #  NOTE: Blocked if noperms is enabled because noperms is used when
        #  the browser is unavailable, thus an incorrect folder can't matter,
        #  while also preventing new Flatpak permission assignment from being
        #  skipped if the browser becomes available again.
        if "lastdownloadsdir" not in configs and not noperms:
            configs["lastdownloadsdir"] = newdownloadsdir
            if "lastflatpak" in configs:
                utils.grantFlatpakDownloadsPerm(self.info.parent["browsertype"], self.info.parent["browser"], newdownloadsdir, configs["downloadsdirname"])
            changesmade = True

        # Assign profiles directory read/write access to the browser if it is now
        #  a Flatpak
        if "lastflatpak" not in configs and newflatpak and not noperms:
            utils.grantFlatpakProfilesPerm(self.info.parent["browsertype"], self.info.parent["browser"], self.profilesdir)
            utils.grantFlatpakDownloadsPerm(self.info.parent["browsertype"], self.info.parent["browser"], newdownloadsdir, configs["downloadsdirname"])
            configs["lastflatpak"] = newflatpak
            changesmade = True

        # Save changes to file if changes were made
        if changesmade:
            with open("%s/.solstice-settings" % self.profilesdir, 'w') as fp:
                fp.write(json.dumps(configs, separators=(',', ':')))
        return configs


    def getAutoload(self, configs):
        if "autoload" not in configs:
            return None
        if type(configs["autoload"]) != str:
            return None #Invalid value
        #Ensure a valid profile exists of the ID
        if os.path.isdir("%s/%s" % (self.profilesdir, configs["autoload"])):
            return configs["autoload"]
        else:
            return None


SolsticeInit()
