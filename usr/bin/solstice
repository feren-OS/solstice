#!/usr/bin/python3

from solstice import main as solstice
from solstice import utils, variables
import os
import sys
import subprocess
import gettext
gettext.install("solstice-gui", "/usr/share/locale", names="ngettext")
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtQml import * #Needs python3-pyqt5.qtquick
from xdg.DesktopEntry import DesktopEntry
import ast
import json

QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)

#######################################################################################
# Solstice Profile Launcher/Manager                                                   #
#                                                                                     #
# Rest in Peace, Mark Greaves.                                                        #
#######################################################################################

if len(sys.argv) < 2:
    print(_("Usage: solstice desktopfile [options]"))
    sys.exit(1)

class SolsticeGUIException(Exception):
    pass

class ProfilesModel(QAbstractListModel):
    IDRole = Qt.UserRole + 1
    NameRole = Qt.UserRole + 2

    def __init__(self, parent=None):
        super().__init__(parent)
        self.profiles = []

    def data(self, index, role=Qt.DisplayRole):
        row = index.row()
        if role == self.IDRole:
            return self.profiles[row]["profileid"]
        if role == self.NameRole:
            return self.profiles[row]["pname"]

    def rowCount(self, parent=QModelIndex()):
        return len(self.profiles)

    def roleNames(self):
        return {self.IDRole: b'profileid', self.NameRole: b'pname'}

    def setData(self, data):
        self.profiles = data
        self.layoutChanged.emit()

class BrowsersModel(QAbstractListModel):
    IDRole = Qt.UserRole + 1
    NameRole = Qt.UserRole + 2
    IconRole = Qt.UserRole + 3
    DescriptionRole = Qt.UserRole + 4
    AvailableRole = Qt.UserRole + 5

    def __init__(self, parent=None):
        super().__init__(parent)
        self.browsers = []

    def data(self, index, role=Qt.DisplayRole):
        row = index.row()
        if role == self.IDRole:
            return self.browsers[row]["browserid"]
        if role == self.NameRole:
            return self.browsers[row]["brname"]
        if role == self.IconRole:
            return self.browsers[row]["bricon"]
        if role == self.DescriptionRole:
            return self.browsers[row]["desc"]
        if role == self.AvailableRole:
            return self.browsers[row]["available"]

    def rowCount(self, parent=QModelIndex()):
        return len(self.browsers)

    def roleNames(self):
        return {self.IDRole: b'browserid', self.NameRole: b'brname',
            self.IconRole: b'bricon', self.DescriptionRole: b'desc',
            self.AvailableRole: b'available'}

    def setData(self, data):
        self.browsers = data
        self.layoutChanged.emit()

class DesktopFileInformation:
    def __init__(self, desktopfile):
        self.info = {}
        try:
            entry=DesktopEntry()
            entry.parse(desktopfile)
        except Exception as e:
            raise SolsticeGUIException(_("Corrupt or missing .desktop file: %s") % e)

        parentid = entry.get("X-Solstice-ParentID")
        if parentid != '': #Child shortcuts have parent IDs, meaning we need some data from their parent shortcut's configs
            self.info["name"] = entry.getName()
            self.info["wmclass"] = entry.getStartupWMClass()
            self.info["website"] = entry.get("X-Solstice-Website")
            try:
                entry.parse(desktopfile)
            except Exception as e:
                raise SolsticeGUIException(_("Corrupt or missing parent .desktop file: %s") % e)
        else: #Parent shortcuts
            self.info["name"] = entry.getName()
            self.info["wmclass"] = entry.getStartupWMClass()
            self.info["website"] = entry.get("X-Solstice-Website")

        self.info["browser"] = entry.get("X-Solstice-Browser")
        self.info["browsertype"] = entry.get("X-Solstice-BrowserType")
        self.info["id"] = entry.get("X-Solstice-ID")
        try:
            self.info["bonusids"] = ast.literal_eval(entry.get("X-Solstice-BonusIDs"))
        except:
            self.info["bonusids"] = []
        self.info["nohistory"] = self.strToBool(entry.get("X-Solstice-NoHistory"))
        self.info["googlehangouts"] = self.strToBool(entry.get("X-Solstice-GoogleHangouts"))
        self.info["bg"] = entry.get("X-Solstice-BG")
        self.info["bgdark"] = entry.get("X-Solstice-BG-Dark")
        self.info["accent"] = entry.get("X-Solstice-Accent")
        self.info["accentdark"] = entry.get("X-Solstice-Accent-Dark")
        self.info["color"] = entry.get("X-Solstice-Color")
        self.info["accentonwindow"] = self.strToBool(entry.get("X-Solstice-AccentWindow"))
        self.info["chromicolor"] = entry.get("X-Solstice-ChromiColor")
        self.info["lastupdated"] = entry.get("X-Solstice-LastUpdate")
        try:
            self.info = utils.complete_item_information(self.info)
        except Exception as e:
            del self.info
            raise SolsticeGUIException(e)

    def strToBool(self, string):
        if string == "true":
            return True
        else:
            return False

class SolsticeGUI(QApplication):
    def __init__(self, infoclass):
        super().__init__(sys.argv)
        self.main = solstice.main()
        self.info = infoclass
        self.mainwnd = None #we manipulate the window numerous times in the code
        self.errorwnd = None #FIXME: Do we manipulate the errorwnd after initial spawning?
        self.maineng = None #storing the engines so they don't get deleted
        self.erroreng = None # after self.open...Window()

        if self.info != {}: #Don't run this code if the file is corrupt
            self.profilesdir = "{0}/{1}".format(variables.solstice_profiles_directory, self.info["id"])
            self.autoload = self.getAutoProfileLoad() #Multiple parts of code get this value
            self.browser = self.info["browser"]
            self.browsertype = self.info["browsertype"]
            browserCheck = self.browserCheck() #It's used again later in the code
            if browserCheck == True:
                self.autoProfileLoad() #If a profile is set to autolaunch, launch it
            guiwmclass = self.info["wmclass"]
        else: #Instead run this code if the file is corrupt
            guiwmclass = "solstice"

        #Set window class
        self.setDesktopFileName(guiwmclass)
        self.setApplicationName(guiwmclass)

        if self.info == {}: #Corrupt file
            self.genericError(_("Incompatible file - Solstice"), _("Corrupt or incompatible file"), _("The shortcut you attempted to open is either corrupt or is too new for this version of Solstice.\n\nPlease reinstall the application you were trying to launch from Store."))
            return

        self.openMainWindow()
        #Set label values, and the window title
        self.interfaceLabels()
        #Apply browser-specific GUI adjustments
        self.refreshBrowserFeatures()
        #Refresh profiles list
        self.refreshProfilesList()
        #Final checks
        if browserCheck == False: #Show the browser selector if browser not available
            self.gotoBrowserSelect()
        else:
            self.gotoProfiles()


    #GUI spawning
    def openMainWindow(self):
        #Set up QML windows
        self.maineng = QQmlApplicationEngine()
        self.maineng.quit.connect(self.quit)
        #Load models
        self.profilesmodel = ProfilesModel()
        self.maineng.rootContext().setContextProperty('ProfilesModel', self.profilesmodel)
        self.browsersmodel = BrowsersModel()
        self.maineng.rootContext().setContextProperty('BrowsersModel', self.browsersmodel)
        #Load QML
        self.maineng.load('/usr/lib/solstice/gui.qml')
        self.mainwnd = self.maineng.rootObjects()[0]
        #Connect main window events
        self.mainwnd.openProfile.connect(self.openProfile)
        self.mainwnd.gotoProfileEditor.connect(self.gotoProfileEditor)
        self.mainwnd.saveProfile.connect(self.saveProfile)
        self.mainwnd.deleteProfile.connect(self.deleteProfile)
        self.mainwnd.setBrowser.connect(self.setBrowser)
        #Load value of autolaunch checkbox
        self.mainwnd.findChild(QObject, "alwaysUseProfile").setProperty('checked', not self.autoload == "")

        #TEMP, TODO
        self.gotoBrowserSelect()

    def openErrorWindow(self):
        if self.mainwnd != None:
            self.mainwnd.hide()
        #Set up QML windows
        self.erroreng = QQmlApplicationEngine()
        self.erroreng.quit.connect(self.quit)
        #Load QML
        self.erroreng.load('/usr/lib/solstice/guierror.qml')
        self.errorwnd = self.erroreng.rootObjects()[0]
        #Connect main window events
        self.errorwnd.dismiss.connect(self.quit)
        self.errorwnd.openStoreBrowsers.connect(self.quit) #TODO
        self.errorwnd.openStoreID.connect(self.quit) #TODO


    #Labels
    def interfaceLabels(self):
        self.mainwnd.setProperty('title', self.info["name"])
        self.mainwnd.findChild(QObject, "profilesHeader").setProperty('text', "Who's using %s?" % self.info["name"])
        self.mainwnd.findChild(QObject, "browsersHeader").setProperty('text', "Choose a browser to launch %s" % self.info["name"])
        self.mainwnd.findChild(QObject, "manageHeader").setProperty('text', "Manage %s Profiles" % self.info["name"])
        self.mainwnd.findChild(QObject, "editProfileSubheader").setProperty('text', "Choose your name, and options for your profile.\nOnce you are done. hit Finish below.")
        #TODO: Add in label changing to translate the labels


    #Browser Management and Checks
    def refreshBrowsersList(self, browsersavailable):
        browsers = []
        for i in browsersavailable: #only contains available browsers of the same browsertype...
            browserdesc = ""
            if "subtitle" in variables.sources[self.browsertype][i]:
                browserdesc = variables.sources[self.browsertype][i]["subtitle"]
            browsers.append({"browserid": i,
                "brname": variables.sources[self.browsertype][i]["name"],
                "bricon": variables.sources[self.browsertype][i]["icon"],
                "desc": browserdesc,
                "available": True})
        for browsertype in variables.sources:
            if browsertype == self.browsertype: #...but we still want to list the others as unavailable.
                continue #Also, skipping the one we already did for obvious reasons.
            for i in variables.sources[browsertype]:
                if not "required-file" in variables.sources[browsertype][i]:
                    continue #Skip dummy browser slots for unavailable browsers
                if not os.path.isfile(variables.sources[browsertype][i]["required-file"][0]):
                    continue #Skip uninstalled browsers
                browserdesc = _("Not available - Website Applications made on non-{0} browsers cannot use {1} as their browser").format(
                    browsertype.capitalize(),
                    variables.sources[browsertype][i]["name"])
                browsers.append({"browserid": i,
                    "brname": variables.sources[browsertype][i]["name"],
                    "bricon": variables.sources[browsertype][i]["icon"],
                    "desc": browserdesc,
                    "available": False})
        #Refresh browsers list in browsersmodel
        self.browsersmodel.setData(browsers)

    def browserCheck(self):
        if not utils.is_browser_available(self.browser, self.browsertype):
            return False
        else:
            return True

    def gotoBrowserSelect(self):
        browsersavailable = []
        try:
            browsersavailable = utils.get_available_browsers(self.browsertype)
        except:
            pass
        if browsersavailable == []:
            self.browserUnavailableError()
            return

        #Refresh model
        self.refreshBrowsersList(browsersavailable)

        if self.browser not in browsersavailable:
            if self.browser in variables.sources[self.browsertype]: #Check if unavailable
                if "unavailable" in variables.sources[self.browsertype][self.browser]:
                    if variables.sources[self.browsertype][self.browser]["unavailable"] == 0: #Changed browsertype
                        pass #TODO: Change labels
                    elif variables.sources[self.browsertype][self.browser]["unavailable"] == 1: #No longer supported
                        pass #TODO: Change labels
            else:
                pass #TODO: Change labels to account for this
            pass #TODO: Disable cancel button

        pass #TODO: Go to Browser Selection page

    def setBrowser(self, newbrowser):
        newfilename = variables.sources[self.browsertype][newbrowser]["classprefix"] + self.info["id"]
        newpath = os.path.join(os.path.dirname(sys.argv[1]), newfilename + ".desktop")

        #Create new shortcut
        with open(sys.argv[1], 'r') as old:
            newshortcut = old.readlines()

        linescounted = 0
        for line in newshortcut:
            if line.startswith("X-Solstice-Browser="):
                newshortcut[linescounted] = "X-Solstice-Browser=" + newbrowser + "\n"
            elif line.startswith("StartupWMClass="):
                newshortcut[linescounted] = "StartupWMClass=" + newfilename + "\n"
            elif line.startswith("Exec="):
                if line.endswith(" --force-manager\n"):
                    newshortcut[linescounted] = 'Exec=/usr/bin/solstice "' + newpath + '" --force-manager\n'
                else:
                    newshortcut[linescounted] = 'Exec=/usr/bin/solstice "' + newpath + '"\n'
            linescounted += 1
        
        os.remove(sys.argv[1]) #Remove old shortcut
        #TODO: Account for if we're running on a child shortcut
        #Write new shortcut
        with open(newpath, 'w') as fp:
            fp.write(''.join(newshortcut))

        #Reload with new file
        commandtorun = list(sys.argv)
        commandtorun[1] = newpath
        subprocess.Popen(commandtorun)
        self.quit()

    def refreshBrowserFeatures(self):
        #Dark mode option
        if utils.is_feature_available(self.browsertype, self.browser, "darkmodeavailable"):
            self.mainwnd.findChild(QObject, "forceDarkMode").setProperty('enabled', True)
            self.mainwnd.findChild(QObject, "forceDarkModeHint").setProperty('text', _("Only works on compatible applications"))
        else:
            self.mainwnd.findChild(QObject, "forceDarkMode").setProperty('enabled', False)
            self.mainwnd.findChild(QObject, "forceDarkModeHint").setProperty('text', _("Not available on %s") % variables.sources[self.browsertype][self.browser]["name"])
        #No cache option
        if utils.is_feature_available(self.browsertype, self.browser, "nocacheavailable"):
            self.mainwnd.findChild(QObject, "noCache").setProperty('enabled', True)
            self.mainwnd.findChild(QObject, "noCacheHint").setProperty('text', _("Worsens load times of websites"))
        else:
            self.mainwnd.findChild(QObject, "noCache").setProperty('enabled', False)
            self.mainwnd.findChild(QObject, "noCacheHint").setProperty('text', _("Not available on %s") % variables.sources[self.browsertype][self.browser]["name"])


    #Error handling
    def genericError(self, wintitle, errortitle, errormessage):
        self.openErrorWindow()

        #Change labels
        self.errorwnd.setProperty('title', wintitle)
        self.errorwnd.findChild(QObject, "genericErrorHeader").setProperty('text', errortitle)
        self.errorwnd.findChild(QObject, "genericErrorSubheader").setProperty('text', errormessage)
        self.errorwnd.findChild(QObject, "genericError").setProperty('visible', True)

    def browserUnavailableError(self):
        self.openErrorWindow()

        #The browser and ID are in self.infoclass
        pass #TODO

    def websiteUnavailableError(self, perma=False, announcement=""):
        #FIXME: Currently goes unused (would this even be feasible, now it's DC'd from Store?)
        self.openErrorWindow()

        #perma: Is the website permanently dead?
        #announcement: Link to the announcement - used if perma is True
        pass #TODO


    #Automatic Profile Loading
    def autoProfileLoad(self):
        #Don't autoload if overridden or there is no configured profile
        if "--force-manager" in sys.argv or self.autoload == "":
            return
        self.openProfile(self.autoload, True, True)
        sys.exit(0) #End the code here

    def getAutoProfileLoad(self):
        result = ""
        #Shortened name to make the multiple times the code uses it shorter too
        solauto = "%s/.solstice-autolaunch" % self.profilesdir
        if not os.path.isfile(solauto):
            return ""
        with open(solauto, 'r') as fp:
            result = fp.readline()
        if not os.path.isdir(utils.get_profilepath(self.info["id"], result)):
            return ""
        return result

    def setAutoProfileLoad(self, value):
        solauto = "%s/.solstice-autolaunch" % self.profilesdir
        if value == "" and os.path.isfile(solauto):
            try:
                os.remove(solauto)
            except Exception as e:
                raise SolsticeGUIException(_("Could not disable automatic profile launching: %s") % e)
            return #Prevent code after this
        elif value == "":
            return #from running if ""
        #Shortened name to make the multiple times the code uses it shorter too
        try:
            with open(solauto, 'w') as fp:
                fp.write(value)
        except Exception as e:
            raise SolsticeGUIException(_("Could not configure automatic profile launching: %s") % e)


    #Profile(s) Checks
    def refreshProfilesList(self):
        if not os.path.isdir(self.profilesdir):
            self.profilesmodel.setData([])
            return
        profiles = []
        for i in os.listdir(self.profilesdir):
            if os.path.isdir(self.profilesdir + "/" + i):
                if os.path.isfile(self.profilesdir + "/" + i + variables.sources[self.browsertype][self.browser]["expected-file"]):
                    readablename = i
                    if os.path.isfile(self.profilesdir + "/" + i + "/.solstice-settings"):
                        with open(self.profilesdir + "/" + i + "/.solstice-settings", 'r') as fp:
                            solsettings = json.loads(fp.read())
                            if "readablename" in solsettings:
                                readablename = solsettings["readablename"]
                    profiles.append({"pname": readablename, "profileid": i})
        #Refresh profiles list in profilesmodel
        self.profilesmodel.setData(profiles)

    def getProfileOutdated(self, profileid):
        profilepath = utils.get_profilepath(self.info["id"], profileid)
        if not os.path.isfile("%s/.solstice-settings" % profilepath):
            return True #lastupdated is in said file
        with open("%s/.solstice-settings" % profilepath, 'r') as fp:
            profileconfs = json.loads(fp.read())
        if "lastupdated" not in profileconfs:
            return True #not having lastupdated means it's outdated by definition
        try:
            if ast.literal_eval(profileconfs["lastupdated"]) < ast.literal_eval(self.info["lastupdated"]):
                return True #profile's last update was earlier than the shortcut's
            else:
                return False #profile is up to date
        except:
            return True #this usually means they aren't numbers, thus outdated by definition


    #Profile management
    def saveProfile(self):
        newname = self.mainwnd.findChild(QObject, "editProfileName").property('text')
        if newname == "":
            self.mainwnd.findChild(QObject, "editProfileNameError").setProperty('text', _("Please enter a name for this profile"))
            return

        darkmode = self.mainwnd.findChild(QObject, "forceDarkMode").property('checked')
        nocache = self.mainwnd.findChild(QObject, "noCache").property('checked')
        try:
            if self.lastedited == "": #New profile
                profileid = utils.profileid_generate(self.profilesdir, self.mainwnd.findChild(QObject, "editProfileName").property('text'))
                #'Update' profile to give it its initial configurations
                self.main.update_profile(self.info, newname, profileid, darkmode, nocache)
            else:
                outdated = utils.get_profile_outdated(self.lastedited, self.info["id"], self.info["lastupdated"])
                self.main.batch_set_profilesettings(self.browsertype, utils.get_profilepath(self.info["id"], self.lastedited), self.info["name"], newname, outdated, darkmode, nocache)
        except Exception as e:
            self.mainwnd.findChild(QObject, "editProfileNameError").setProperty('text', _("Failed to save changes"))
            print(e)
            return

        self.mainwnd.findChild(QObject, "editProfileNameError").setProperty('text', _(""))
        if self.lastedited == "":
            #Automatically launch newly created profile
            self.openProfile(profileid, False)
        else:
            #Refresh profiles list and return to profile manager
            self.refreshProfilesList()
            self.gotoManager()
        del self.lastedited #delete the variable as it is now redundant

    def gotoProfileEditor(self, newprofile, profileid=""):
        self.lastedited = profileid
        self.mainwnd.findChild(QObject, "editProfileNameError").setProperty('text', _(""))
        if newprofile == True:
            self.mainwnd.findChild(QObject, "editProfileHeader").setProperty('text', _("Create a profile"))
            self.mainwnd.findChild(QObject, "deleteProfileBtn").setProperty('enabled', False)
            self.mainwnd.findChild(QObject, "editProfileName").setProperty('text', "")
            self.mainwnd.findChild(QObject, "forceDarkMode").setProperty('checked', False)
            self.mainwnd.findChild(QObject, "noCache").setProperty('checked', False)
        else:
            profilename, nocache, darkmode = utils.get_profile_settings(self.info["id"], profileid) #Getting necessary values
            self.mainwnd.findChild(QObject, "editProfileHeader").setProperty('text', _("Configuring %s") % profilename)
            self.mainwnd.findChild(QObject, "deleteProfileBtn").setProperty('enabled', True)
            self.mainwnd.findChild(QObject, "editProfileName").setProperty('text', profilename)
            self.mainwnd.findChild(QObject, "forceDarkMode").setProperty('checked', darkmode)
            self.mainwnd.findChild(QObject, "noCache").setProperty('checked', nocache)
        self.mainwnd.findChild(QObject, "pages").setProperty('currentIndex', 2)
        self.mainwnd.findChild(QObject, "editProfileName").forceActiveFocus(True)

    def updateProfile(self, profileid):
        profilename, nocache, darkmode = utils.get_profile_settings(self.info["id"], profileid) #Getting necessary values
        self.main.update_profile(self.info, profilename, profileid, darkmode, nocache)

    def gotoProfiles(self):
        if self.profilesmodel.profiles == []: #Jump to profile creator if there are no profiles
            self.gotoProfileEditor(True)
        else:
            self.mainwnd.findChild(QObject, "pages").setProperty('currentIndex', 0)
            self.mainwnd.findChild(QObject, "profileSelect").forceActiveFocus(True)

    def gotoManager(self):
        if self.profilesmodel.profiles == []: #Jump to profile creator if there are no profiles
            self.gotoProfileEditor(True)
        else:
            self.mainwnd.findChild(QObject, "pages").setProperty('currentIndex', 1)
            self.mainwnd.findChild(QObject, "profileManager").forceActiveFocus(True)

    def deleteProfile(self):
        #The only time we can press this button is inside the Editor.
        #Therefore, since self.lastedited exists during such times, we can use it for the profile ID
        self.main.delete_profile(self.info, self.lastedited)

        self.refreshProfilesList()
        self.gotoManager()


    #Run profile
    def openProfile(self, profileid, alwaysuse, auto=False):
        #Set autostart if alwaysuse is True
        if auto == False: #Don't change autoload if autoloading
            if alwaysuse == True and self.autoload != profileid: #Reducing file-writes
                self.setAutoProfileLoad(profileid)
            elif alwaysuse == False:
                self.setAutoProfileLoad("")

        #Check lastupdated of profile against shortcut's lastupdated
        if utils.get_profile_outdated(profileid, self.info["id"], self.info["lastupdated"]) == True:
            print("testy")
            self.updateProfile(profileid) #Update the profile if the shortcut's younger
            #TODO: Add exception catches to show error dialog

        #Start the requested profile
        self.main.run_profile(self.info["id"], profileid, self.info["browser"], self.info["browsertype"], self.info["website"], self.info["wmclass"], self.info["nohistory"], self.closeCallback if not auto else None)

        self.quit()

    #Callback to close mainwnd
    def closeCallback(self):
        self.mainwnd.close()

app = None
if not os.path.isfile(sys.argv[1]):
    sys.exit(2)
try:
    infoclass = DesktopFileInformation(sys.argv[1])
except Exception as e:
    print("Failed to load shortcut: %s" % e)
    app = SolsticeGUI({})
else:
    app = SolsticeGUI(infoclass.info)

sys.exit(app.exec())
