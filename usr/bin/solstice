#!/usr/bin/python3

from solstice import main as solstice
from solstice import utils, variables
import sys
import gettext
gettext.install("solstice-gui", "/usr/share/locale", names="ngettext")
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtQml import * #Needs python3-pyqt5.qtquick
from xdg.DesktopEntry import DesktopEntry
import ast

QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)

#######################################################################################
# Solstice Profile Launcher/Manager                                                   #
#                                                                                     #
# Rest in Peace, Mark Greaves.                                                        #
#######################################################################################

if len(sys.argv) < 2:
    print(_("Usage: solstice desktopfile [options]"))
    sys.exit(1)

class SolsticeGUIException(Exception):
    pass

class ProfilesModel(QAbstractListModel):
    IDRole = Qt.UserRole + 1
    NameRole = Qt.UserRole + 2

    def __init__(self, parent=None):
        super().__init__(parent)
        self.profiles = []

    def data(self, index, role=Qt.DisplayRole):
        row = index.row()
        if role == self.IDRole:
            return self.profiles[row]["profileid"]
        if role == self.NameRole:
            return self.profiles[row]["pname"]

    def rowCount(self, parent=QModelIndex()):
        return len(self.profiles)

    def roleNames(self):
        return {self.IDRole: b'profileid', self.NameRole: b'pname'}

    def setData(self, data):
        self.profiles = data
        self.layoutChanged.emit()

class BrowsersModel(QAbstractListModel):
    IDRole = Qt.UserRole + 1
    NameRole = Qt.UserRole + 2
    IconRole = Qt.UserRole + 3
    DescriptionRole = Qt.UserRole + 4
    AvailableRole = Qt.UserRole + 5

    def __init__(self, parent=None):
        super().__init__(parent)
        self.browsers = []

    def data(self, index, role=Qt.DisplayRole):
        row = index.row()
        if role == self.IDRole:
            return self.browsers[row]["profileid"]
        if role == self.NameRole:
            return self.browsers[row]["brname"]
        if role == self.IconRole:
            return self.browsers[row]["bricon"]
        if role == self.DescriptionRole:
            return self.browsers[row]["desc"]
        if role == self.AvailableRole:
            return self.browsers[row]["available"]

    def rowCount(self, parent=QModelIndex()):
        return len(self.browsers)

    def roleNames(self):
        return {self.IDRole: b'profileid', self.NameRole: b'brname', }

    def setData(self, data):
        self.browsers = data
        self.layoutChanged.emit()

class DesktopFileInformation:
    def __init__(self, desktopfile):
        self.info = {}
        try:
            entry=DesktopEntry()
            entry.parse(desktopfile)
        except Exception as e:
            raise SolsticeGUIException(_("Corrupt or missing .desktop file: %s") % e)

        parentid = entry.get("X-Solstice-ParentID")
        if parentid != '': #Child shortcuts have parent IDs, meaning we need some data from their parent shortcut's configs
            self.info["name"] = entry.getName()
            self.info["wmclass"] = entry.getStartupWMClass()
            self.info["website"] = entry.get("X-Solstice-Website")
            try:
                entry.parse(desktopfile)
            except Exception as e:
                raise SolsticeGUIException(_("Corrupt or missing parent .desktop file: %s") % e)
        else: #Parent shortcuts
            self.info["name"] = entry.getName()
            self.info["wmclass"] = entry.getStartupWMClass()
            self.info["website"] = entry.get("X-Solstice-Website")

        self.info["browser"] = entry.get("X-Solstice-Browser")
        self.info["browsertype"] = entry.get("X-Solstice-BrowserType")
        self.info["id"] = entry.get("X-Solstice-ID")
        try:
            self.info["bonusids"] = ast.literal_eval(entry.get("X-Solstice-BonusIDs"))
        except:
            self.info["bonusids"] = []
        self.info["nohistory"] = self.strToBool(entry.get("X-Solstice-NoHistory"))
        self.info["nocache"] = self.strToBool(entry.get("X-Solstice-NoCache"))
        self.info["googlehangouts"] = self.strToBool(entry.get("X-Solstice-GoogleHangouts"))
        self.info["bg"] = entry.get("X-Solstice-BG")
        self.info["bgdark"] = entry.get("X-Solstice-BG-Dark")
        self.info["accent"] = entry.get("X-Solstice-Accent")
        self.info["accentdark"] = entry.get("X-Solstice-Accent-Dark")
        self.info["color"] = entry.get("X-Solstice-Color")
        self.info["accentonwindow"] = self.strToBool(entry.get("X-Solstice-AccentWindow"))
        self.info["chromicolor"] = entry.get("X-Solstice-ChromiColor")
        self.info["chromicolordark"] = entry.get("X-Solstice-ChromiColor-Dark")
        self.info["lastupdated"] = entry.get("X-Solstice-LastUpdate")
        try:
            self.info = utils.complete_item_information(self.info)
        except Exception as e:
            self.info = {}
            raise SolsticeGUIException(e)

    def strToBool(self, string):
        if string == "true":
            return True
        else:
            return False

class SolsticeGUI(QApplication):
    def __init__(self, infoclass):
        super().__init__(sys.argv)
        self.main = solstice.main()
        self.info = infoclass
        self.mainwnd = None
        self.errorwnd = None
        self.maineng = None #storing the engines so they don't get deleted
        self.erroreng = None

        if self.info != {}: #Don't run this code if the file is corrupt
            self.profilesdir = "{0}/{1}".format(variables.solstice_profiles_directory, self.info["id"])
            self.autoload = self.getAutoProfileLoad()
            self.browser = self.info["browser"]
            self.browsertype = self.info["browsertype"]
            browserCheck = self.browserCheck()
            if browserCheck == True:
                self.autoProfileLoad() #If a profile is set to autolaunch, launch it
            guiwmclass = self.info["wmclass"]
        else:
            guiwmclass = "solstice"

        #Set window class
        self.setDesktopFileName(guiwmclass)
        self.setApplicationName(guiwmclass)

        if self.info == {}: #Corrupt file
            self.genericError(_("Incompatible file - Solstice"), _("Corrupt or incompatible file"), _("The shortcut you attempted to open is either corrupt or is too new for this version of Solstice.\n\nPlease reinstall the application you were trying to launch from Store."))
            return

        self.openMainWindow()
        #Set label values, and the window title
        guiname = self.info["name"]
        self.mainwnd.setProperty('title', guiname)
        self.mainwnd.findChild(QObject, "profilesHeader").setProperty('text', "Who's using %s?" % guiname)
        self.mainwnd.findChild(QObject, "browsersHeader").setProperty('text', "Choose a browser to launch %s" % guiname)
        self.mainwnd.findChild(QObject, "manageHeader").setProperty('text', "Manage %s Profiles" % guiname)
        self.mainwnd.findChild(QObject, "editProfileSubheader").setProperty('text', "Choose your name, and options for your profile.\nOnce you are done. hit Finish below.")
        #TODO: Add in label changing to translate the labels
        #Final checks
        if browserCheck == False: #Show the browser selector if browser not available
            self.browserSelect()

    def openMainWindow(self):
        #Set up QML windows
        self.maineng = QQmlApplicationEngine()
        self.maineng.quit.connect(self.quit)
        #Load models
        self.profilesmodel = ProfilesModel()
        self.maineng.rootContext().setContextProperty('ProfilesModel', self.profilesmodel)
        self.browsersmodel = BrowsersModel()
        self.maineng.rootContext().setContextProperty('BrowsersModel', self.browsersmodel)
        #Load QML
        self.maineng.load('/usr/lib/solstice/gui.qml')
        self.mainwnd = self.maineng.rootObjects()[0]
        #Connect main window events
        self.mainwnd.editProfile.connect(onEditProfile)
        self.mainwnd.openProfile.connect(onOpenProfile)
        self.mainwnd.enterEditProfile.connect(onEnterEditProfile)
        self.mainwnd.enterCreateProfile.connect(onEnterCreateProfile)
        self.mainwnd.deleteProfile.connect(onDeleteProfile)

    def openErrorWindow(self):
        if self.mainwnd != None:
            self.mainwnd.hide()
        #Set up QML windows
        self.erroreng = QQmlApplicationEngine()
        self.erroreng.quit.connect(self.quit)
        #Load QML
        self.erroreng.load('/usr/lib/solstice/guierror.qml')
        self.errorwnd = self.erroreng.rootObjects()[0]
        #Connect main window events
        self.errorwnd.dismiss.connect(self.quit)
        self.errorwnd.openStoreBrowsers.connect(self.quit) #TODO
        self.errorwnd.openStoreID.connect(self.quit) #TODO

    def autoProfileLoad(self):
        #Don't autoload if --force-manager is currently in effect
        if "--force-manager" in sys.argv:
            return
        self.openProfile(self.autoload, True, True)

    def getAutoProfileLoad(self):
        result = ""
        #Shortened name to make the multiple times the code uses it shorter too
        solauto = "%s/.solstice-autolaunch" % self.profilesdir
        if not os.path.isfile(solauto):
            return ""
        with open(solauto, 'r') as fp:
            result = fp.readline()
        return result

    def setAutoProfileLoad(self, value):
        if value == "" and os.path.isfile(solauto):
            try:
                os.remove(solauto)
            except Exception as e:
                raise SolsticeGUIException(_("Could not disable automatic profile launching: %s") % e)
        elif value == "":
            return
        #Shortened name to make the multiple times the code uses it shorter too
        solauto = "%s/.solstice-autolaunch" % self.profilesdir
        try:
            with open(solauto, 'w') as fp:
                fp.write(value)
        except Exception as e:
            raise SolsticeGUIException(_("Could not configure automatic profile launching: %s") % e)

    def getProfiles(self):
        profiles = []
        for i in os.listdir(self.profilesdir):
            if os.path.isdir(self.profilesdir + "/" + i):
                if os.path.isfile(self.profilesdir + "/" + i + variables.sources[self.browsertype][self.browser]["expected-file"]):
                    readablename = i
                    if os.path.isfile(self.profilesdir + "/" + i + "/.solstice-settings"):
                        with open(self.profilesdir + "/" + i + "/.solstice-settings", 'r') as fp:
                            solsettings = json.loads(fp.read())
                            if "readablename" in solsettings:
                                readablename = solsettings["readablename"]
                    profiles.append({"myname": readablename, "profileid": i})
        return profiles

    def getProfileOutdated(self, profileid):
        profilepath = utils.get_profilepath(self.info["id"], profileid)
        if not os.path.isfile("%s/.solstice-settings" % profilepath):
            return True #lastupdated is in said file
        with open("%s/.solstice-settings" % profilepath, 'r') as fp:
            profileconfs = json.loads(fp.read())
        if "lastupdated" not in profileconfs:
            return True #not having lastupdated means it's outdated by definition
        try:
            if int(profileconfs["lastupdated"]) < int(self.info["lastupdated"]):
                return True #profile's last update was earlier than the shortcut's
            else:
                return False #profile is up to date
        except:
            return True #this usually means they aren't numbers, thus outdated by definition

    def browserCheck(self):
        if not utils.is_browser_available(self.browser, self.browsertype):
            return False
        else:
            return True

    def browserSelect(self):
        browsersavailable = []
        try:
            browsersavailable = utils.get_available_browsers(self.browsertype)
        except:
            pass
        if browsersavailable == []:
            self.browserUnavailableError()
            return

        if self.browser not in browsersavailable:
            if self.browser in variables.sources[self.browsertype]: #Check if unavailable
                if "unavailable" in variables.sources[self.browsertype][self.browser]:
                    if variables.sources[self.browsertype][self.browser]["unavailable"] == 0: #Changed browsertype
                        pass #TODO: Change labels
                    elif variables.sources[self.browsertype][self.browser]["unavailable"] == 1: #No longer supported
                        pass #TODO: Change labels
            else:
                pass #TODO: Change labels to account for this
            pass #TODO: Disable cancel button

        pass #TODO: Go to Browser Selection page

    def genericError(self, wintitle, errortitle, errormessage):
        self.openErrorWindow()

        #Change labels
        self.errorwnd.setProperty('title', wintitle)
        self.errorwnd.findChild(QObject, "genericErrorHeader").setProperty('text', errortitle)
        self.errorwnd.findChild(QObject, "genericErrorSubheader").setProperty('text', errormessage)
        self.errorwnd.findChild(QObject, "genericError").setProperty('visible', True)

    def browserUnavailableError(self):
        self.openErrorWindow()

        #The browser and ID are in self.infoclass
        pass #TODO

    def websiteUnavailableError(self, perma=False, announcement=""):
        #FIXME: Currently goes unused (would this even be feasible, now it's DC'd from Store?)
        self.openErrorWindow()

        #perma: Is the website permanently dead?
        #announcement: Link to the announcement - used if perma is True
        pass #TODO

    def openProfile(self, profileid, alwaysuse, auto=False):
        #Set autostart if alwaysuse is True
        if auto == False: #Don't change autoload if autoloading
            if alwaysuse == True and self.autoload != profileid:
                self.setAutoProfileLoad(profileid)
            elif alwaysuse == False:
                self.setAutoProfileLoad("")

        #Check lastupdated of profile against shortcut's lastupdated, and if shortcut's is younger then update the profile
        if self.getProfileOutdated(profileid) == True:
            profilename, nocache, darkmode = utils.get_profile_settings(self.info["id"], profileid)
            self.main.update_profile(self.info, profilename, profileid, darkmode, nocache)
            #TODO: Add exception catches to show error dialog

        #Start the requested profile
        self.main.run_profile(self.info["id"], profileid, self.info["browser"], self.info["browsertype"], self.info["website"], self.info["wmclass"], self.info["nohistory"], self.closeCallback if not auto else None)

        self.quit()

app = None
try:
    infoclass = DesktopFileInformation(str(sys.argv[1]))
except Exception as e:
    print("Failed to load shortcut: %s" % e)
    app = SolsticeGUI({})
else:
    app = SolsticeGUI(infoclass.info)

sys.exit(app.exec())
