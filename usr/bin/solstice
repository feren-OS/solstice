#!/usr/bin/python3

from solstice import main as solstice
from solstice import utils, variables
import os
import sys
import subprocess
import gettext
gettext.install("solstice-gui", "/usr/share/locale", names="ngettext")
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtQml import * #Needs python3-pyqt5.qtquick
from xdg.DesktopEntry import DesktopEntry
import ast
import json

QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)

#######################################################################################
# Solstice Profile Launcher/Manager                                                   #
#                                                                                     #
# Rest in Peace, Mark Greaves.                                                        #
#######################################################################################

if len(sys.argv) < 2:
    print(_("Usage: solstice desktopfile [options]"))
    sys.exit(1)

class SolsticeGUIException(Exception):
    pass

class ProfilesModel(QAbstractListModel):
    IDRole = Qt.UserRole + 1
    NameRole = Qt.UserRole + 2

    def __init__(self, parent=None):
        super().__init__(parent)
        self.profiles = []

    def data(self, index, role=Qt.DisplayRole):
        row = index.row()
        if role == self.IDRole:
            return self.profiles[row]["profileid"]
        if role == self.NameRole:
            return self.profiles[row]["pname"]

    def rowCount(self, parent=QModelIndex()):
        return len(self.profiles)

    def roleNames(self):
        return {self.IDRole: b'profileid', self.NameRole: b'pname'}

    def setData(self, data):
        self.profiles = data
        self.layoutChanged.emit()

class BrowsersModel(QAbstractListModel):
    IDRole = Qt.UserRole + 1
    NameRole = Qt.UserRole + 2
    IconRole = Qt.UserRole + 3
    DescriptionRole = Qt.UserRole + 4
    AvailableRole = Qt.UserRole + 5
    PrecheckedRole = Qt.UserRole + 6

    def __init__(self, parent=None):
        super().__init__(parent)
        self.browsers = []

    def data(self, index, role=Qt.DisplayRole):
        row = index.row()
        if role == self.IDRole:
            return self.browsers[row]["browserid"]
        if role == self.NameRole:
            return self.browsers[row]["brname"]
        if role == self.IconRole:
            return self.browsers[row]["bricon"]
        if role == self.DescriptionRole:
            return self.browsers[row]["desc"]
        if role == self.AvailableRole:
            return self.browsers[row]["available"]
        if role == self.PrecheckedRole: #For preselecting current choice
            return self.browsers[row]["prechecked"]

    def rowCount(self, parent=QModelIndex()):
        return len(self.browsers)

    def roleNames(self):
        return {self.IDRole: b'browserid', self.NameRole: b'brname',
            self.IconRole: b'bricon', self.DescriptionRole: b'desc',
            self.AvailableRole: b'available', self.PrecheckedRole: b'prechecked'}

    def setData(self, data):
        self.browsers = data
        self.layoutChanged.emit()

class DesktopFileInformation:
    def __init__(self, desktopfile):
        self.info = {}
        try:
            entry=DesktopEntry()
            entry.parse(desktopfile)
        except Exception as e:
            raise SolsticeGUIException(_("Corrupt or missing .desktop file: %s") % e)

        parentid = entry.get("X-Solstice-ParentID")
        if parentid != '': #Child shortcuts have parent IDs, meaning we need some data from their parent shortcut's configs
            self.info["parentid"] = parentid
            self.info["name"] = entry.getName()
            self.info["solwmclass"] = entry.getStartupWMClass()
            self.info["website"] = entry.get("X-Solstice-Website")
            desktopfilelist = desktopfile.split("/")
            desktopfilelist[-1] = desktopfilelist[-1].replace(entry.get("X-Solstice-ID"), parentid)
            desktopfile = "/".join(desktopfilelist)
            del desktopfilelist
            try:
                entry.parse(desktopfile)
            except Exception as e:
                raise SolsticeGUIException(_("Corrupt or missing parent .desktop file: %s") % e)
        else: #Parent shortcuts
            self.info["name"] = entry.getName()
            self.info["solwmclass"] = entry.getStartupWMClass()
            self.info["website"] = entry.get("X-Solstice-Website")

        self.info["wmclass"] = entry.getStartupWMClass()
        self.info["browser"] = entry.get("X-Solstice-Browser")
        self.info["browsertype"] = entry.get("X-Solstice-BrowserType")
        self.info["id"] = entry.get("X-Solstice-ID")
        self.info["storeid"] = entry.get("X-Solstice-StoreID")
        try:
            self.info["bonusids"] = ast.literal_eval(entry.get("X-Solstice-BonusIDs"))
        except:
            self.info["bonusids"] = []
        self.info["nohistory"] = self.strToBool(entry.get("X-Solstice-NoHistory"))
        self.info["googlehangouts"] = self.strToBool(entry.get("X-Solstice-GoogleHangouts"))
        try:
            self.info["extrawebsites"] = ast.literal_eval("X-Solstice-ExtraWebsites")
        except:
            self.info["extrawebsites"] = []
        self.info["bg"] = entry.get("X-Solstice-BG")
        self.info["bgdark"] = entry.get("X-Solstice-BG-Dark")
        self.info["accent"] = entry.get("X-Solstice-Accent")
        self.info["accentdark"] = entry.get("X-Solstice-Accent-Dark")
        self.info["color"] = entry.get("X-Solstice-Color")
        self.info["accentonwindow"] = self.strToBool(entry.get("X-Solstice-AccentWindow"))
        self.info["chromicolor"] = entry.get("X-Solstice-ChromiColor")
        self.info["lastupdated"] = entry.get("X-Solstice-LastUpdate")
        try:
            self.info = utils.complete_item_information(self.info)
        except Exception as e:
            del self.info
            raise SolsticeGUIException(e)

    def strToBool(self, string):
        if string == "true":
            return True
        else:
            return False

class SolsticeGUI(QApplication):
    def __init__(self, infoclass):
        super().__init__(sys.argv)
        self.main = solstice.main()
        self.info = infoclass
        self.mainwnd = None #we manipulate the window numerous times in the code
        self.errorwnd = None #FIXME: Do we manipulate the errorwnd after initial spawning?
        self.maineng = None #storing the engines so they don't get deleted
        self.erroreng = None # after self.open...Window()

        if self.info != {}: #Don't run this code if the file is corrupt
            self.profilesdir = "{0}/{1}".format(variables.solstice_profiles_directory, self.info["id"])
            self.autoload = self.getAutoProfileLoad() #Multiple parts of code get this value
            self.browser = self.info["browser"]
            self.browsertype = self.info["browsertype"]
            browserCheck = self.browserCheck() #It's used again later in the code
            if browserCheck == True:
                self.autoProfileLoad() #If a profile is set to autolaunch, launch it
            guiwmclass = self.info["solwmclass"]
        else: #Instead run this code if the file is corrupt
            guiwmclass = "solstice"

        #Set window class
        self.setDesktopFileName(guiwmclass)
        self.setApplicationName(guiwmclass)

        if self.info == {}: #Corrupt file
            self.genericError(_("Incompatible file - Solstice"), _("Corrupt or incompatible file"), _("The shortcut you attempted to open is either corrupt or is too new for this version of Solstice.\n\nPlease reinstall the application you were trying to launch from Store."))
            return
        if self.browsertype not in variables.sources or self.browser not in variables.sources[self.browsertype]: #Invalid browser
            print(_("Failed to load shortcut: %s") % _("Invalid browser"))
            self.genericError(_("Incompatible file - Solstice"), _("Corrupt or incompatible file"), _("The shortcut you attempted to open is either corrupt or is too new for this version of Solstice.\n\nPlease reinstall the application you were trying to launch from Store."))
            return
        
        #Set up QML windows
        self.maineng = QQmlApplicationEngine()
        self.maineng.quit.connect(self.quit)

        self.openMainWindow()
        #Set label values, and the window title
        self.interfaceLabels()
        #Apply browser-specific GUI adjustments
        self.refreshBrowserFeatures()
        #Final checks
        if browserCheck == False: #Show the browser selector if browser not available
            self.gotoBrowserSelect()
        else:
            #Refresh profiles list, and go to profile select
            self.refreshProfilesList()
            self.gotoProfiles()


    #GUI spawning
    def openMainWindow(self):
        #Load models
        self.profilesmodel = ProfilesModel()
        self.maineng.rootContext().setContextProperty('ProfilesModel', self.profilesmodel)
        self.browsersmodel = BrowsersModel()
        self.maineng.rootContext().setContextProperty('BrowsersModel', self.browsersmodel)
        #Load condition-variables
        if "storeid" in self.info:
            self.maineng.rootContext().setContextProperty('fromStore', self.info["storeid"] != "")
        else:
            self.maineng.rootContext().setContextProperty('fromStore', False)
        if os.path.isfile("/usr/bin/feren-store"):
            self.maineng.rootContext().setContextProperty('storeAvailable', True)
        else:
            self.maineng.rootContext().setContextProperty('storeAvailable', False)
        self.maineng.rootContext().setContextProperty('bonusesAvailable', False) #changed later
        #Load QML
        self.maineng.load('/usr/lib/solstice/gui.qml')
        self.mainwnd = self.maineng.rootObjects()[0]
        #Connect main window events
        self.mainwnd.openProfile.connect(self.openProfile)
        self.mainwnd.gotoProfileEditor.connect(self.gotoProfileEditor)
        self.mainwnd.saveProfile.connect(self.saveProfile)
        self.mainwnd.deleteProfile.connect(self.deleteProfile)
        self.mainwnd.gotoBrowserSelect.connect(self.gotoBrowserSelect)
        self.mainwnd.setBrowser.connect(self.setBrowser)
        #Load value of autolaunch checkbox
        self.mainwnd.findChild(QObject, "alwaysUseProfile").setProperty('checked', not self.autoload == "")

    def openErrorWindow(self):
        if self.mainwnd != None:
            self.mainwnd.hide()
        #Set up QML windows
        self.erroreng = QQmlApplicationEngine()
        self.erroreng.quit.connect(self.quit)
        #Load condition-variables
        if os.path.isfile("/usr/bin/feren-store"):
            self.erroreng.rootContext().setContextProperty('storeAvailable', True)
        else:
            self.erroreng.rootContext().setContextProperty('storeAvailable', False)
        #Load QML
        self.erroreng.load('/usr/lib/solstice/guierror.qml')
        self.errorwnd = self.erroreng.rootObjects()[0]
        #Connect main window events
        self.errorwnd.dismiss.connect(self.quit)
        self.errorwnd.openStoreBrowsers.connect(self.quit) #TODO
        self.errorwnd.openStoreID.connect(self.quit) #TODO


    #Labels
    def interfaceLabels(self):
        self.mainwnd.setProperty('title', self.info["name"])
        self.mainwnd.findChild(QObject, "profilesHeader").setProperty('text', "Who's using %s?" % self.info["name"])
        self.mainwnd.findChild(QObject, "browsersHeader").setProperty('text', "Choose a browser to launch %s" % self.info["name"])
        self.mainwnd.findChild(QObject, "manageHeader").setProperty('text', "Manage %s Profiles" % self.info["name"])
        self.mainwnd.findChild(QObject, "editProfileSubheader").setProperty('text', "Choose your name, and options for your profile.\nOnce you are done. hit Finish below.")
        #TODO: Add in label changing to translate the labels


    #Browser Management and Checks
    def refreshBrowsersList(self, browsersavailable):
        browsers = []
        for i in browsersavailable: #only contains available browsers of the same browsertype...
            browserdesc = ""
            if "subtitle" in variables.sources[self.browsertype][i]:
                browserdesc = variables.sources[self.browsertype][i]["subtitle"]
            browsers.append({"browserid": i,
                "brname": variables.sources[self.browsertype][i]["name"],
                "bricon": variables.sources[self.browsertype][i]["icon"],
                "desc": browserdesc,
                "available": True,
                "prechecked": i == self.browser})
        for browsertype in variables.sources:
            if browsertype == self.browsertype: #...but we still want to list the others as unavailable.
                continue #Also, skipping the one we already did for obvious reasons.
            for i in variables.sources[browsertype]:
                if not "required-file" in variables.sources[browsertype][i]:
                    continue #Skip dummy browser slots for unavailable browsers
                if not os.path.isfile(variables.sources[browsertype][i]["required-file"][0]):
                    continue #Skip uninstalled browsers
                browserdesc = _("Not available - Website Applications made on non-{0} browsers cannot use {1} as their browser").format(
                    browsertype.capitalize(),
                    variables.sources[browsertype][i]["name"])
                browsers.append({"browserid": i,
                    "brname": variables.sources[browsertype][i]["name"],
                    "bricon": variables.sources[browsertype][i]["icon"],
                    "desc": browserdesc,
                    "available": False,
                    "prechecked": False})
        #Refresh browsers list in browsersmodel
        self.browsersmodel.setData(browsers)

    def browserCheck(self):
        if not utils.is_browser_available(self.browser, self.browsertype):
            return False
        else:
            return True

    def gotoBrowserSelect(self):
        browsersavailable = []
        try:
            browsersavailable = utils.get_available_browsers(self.browsertype)
        except:
            pass
        if browsersavailable == []:
            self.browserUnavailableError()
            return

        #Refresh model
        self.refreshBrowsersList(browsersavailable)

        if self.browser not in browsersavailable:
            self.mainwnd.findChild(QObject, "cancelBrowserSelect").setProperty('enabled', False) #Disable cancel button
            self.mainwnd.findChild(QObject, "browsersSubheader").setProperty('text', _("The browser used to launch this application is missing or has been removed.\nTo continue, please choose a replacement browser below."))
            if self.browser in variables.sources[self.browsertype]: #Check if unavailable
                if "unavailable" in variables.sources[self.browsertype][self.browser]:
                    if variables.sources[self.browsertype][self.browser]["unavailable"] == 0: #Changed browsertype
                        self.mainwnd.findChild(QObject, "browsersSubheader").setProperty('text', _("The browser used to launch this application has changed browser engines, and is no longer compatible with %s's profiles.\nTo continue, please choose a replacement browser below.") % self.info["name"])
                    elif variables.sources[self.browsertype][self.browser]["unavailable"] == 1: #No longer supported
                        self.mainwnd.findChild(QObject, "browsersSubheader").setProperty('text', _("The browser used to launch this application is no longer compatible.\nTo continue, please choose a replacement browser below."))
        else: #Visiting the browser changer manually
            self.mainwnd.findChild(QObject, "browsersSubheader").setProperty('text', _("Select a browser from the options below to use it for this application.\nIf you want to keep your current preference, press Cancel."))
            self.mainwnd.findChild(QObject, "cancelBrowserSelect").setProperty('enabled', True)

        #Go to browser selection page
        self.mainwnd.findChild(QObject, "pages").setProperty('currentIndex', 3)

    def setBrowser(self, newbrowser):
        newpath = utils.set_browser(sys.argv[1], self.browsertype, self.info["id"], self.info["name"], self.browser, newbrowser)

        #Reload with new file
        commandtorun = list(sys.argv)
        commandtorun[1] = newpath
        subprocess.Popen(commandtorun)
        self.quit()

    def refreshBrowserFeatures(self):
        #But can it do bonuses?
        if utils.is_feature_available(self.browsertype, self.browser, "bonusesavailable"):
            self.maineng.rootContext().setContextProperty('bonusesAvailable', True)
        else:
            self.maineng.rootContext().setContextProperty('bonusesAvailable', False)
        #Dark mode option
        if utils.is_feature_available(self.browsertype, self.browser, "darkmodeavailable"):
            self.mainwnd.findChild(QObject, "forceDarkMode").setProperty('enabled', True)
            self.mainwnd.findChild(QObject, "forceDarkModeHint").setProperty('text', _("Only works on compatible applications"))
        else:
            self.mainwnd.findChild(QObject, "forceDarkMode").setProperty('enabled', False)
            self.mainwnd.findChild(QObject, "forceDarkModeHint").setProperty('text', _("Not available on %s") % variables.sources[self.browsertype][self.browser]["name"])
        #No cache option
        if utils.is_feature_available(self.browsertype, self.browser, "nocacheavailable"):
            self.mainwnd.findChild(QObject, "noCache").setProperty('enabled', True)
            self.mainwnd.findChild(QObject, "noCacheHint").setProperty('text', _("Worsens load times of websites"))
        else:
            self.mainwnd.findChild(QObject, "noCache").setProperty('enabled', False)
            self.mainwnd.findChild(QObject, "noCacheHint").setProperty('text', _("Not available on %s") % variables.sources[self.browsertype][self.browser]["name"])


    #Error handling
    def genericError(self, wintitle, errortitle, errormessage):
        self.openErrorWindow()

        #Change labels
        self.errorwnd.setProperty('title', wintitle)
        self.errorwnd.findChild(QObject, "genericErrorHeader").setProperty('text', errortitle)
        self.errorwnd.findChild(QObject, "genericErrorSubheader").setProperty('text', errormessage)
        self.errorwnd.findChild(QObject, "genericError").setProperty('visible', True)

    def browserUnavailableError(self):
        self.openErrorWindow()

        #The browser and ID are in self.infoclass
        #Change labels
        self.errorwnd.setProperty('title', _("No browsers available - %s") % self.info["name"])
        self.errorwnd.findChild(QObject, "noBrowsersHeader").setProperty('text', _("No browsers are available for %s") % self.info["name"])
        self.errorwnd.findChild(QObject, "noBrowsersSubheader").setProperty('text', _("Unfortunately, %s cannot currently start as there are no installed browsers that can run it.") % self.info["name"])
        self.errorwnd.findChild(QObject, "noBrowsersError").setProperty('visible', True)
        if self.browser in variables.sources[self.browsertype]: #Check if unavailable
            if "unavailable" in variables.sources[self.browsertype][self.browser]:
                self.errorwnd.findChild(QObject, "browserSubstituteTitle").setProperty('text', _("{0} can no longer run {1}").format(variables.sources[self.browsertype][self.browser]["name"], self.info["name"]))
                if variables.sources[self.browsertype][self.browser]["unavailable"] == 0: #Changed browsertype
                    self.errorwnd.findChild(QObject, "browserSubstituteDesc").setProperty('text', _("The browser used to launch this application has changed browser engines, and is no longer compatible with %s's profiles.") % self.info["name"])
                elif variables.sources[self.browsertype][self.browser]["unavailable"] == 1: #No longer supported
                    self.errorwnd.findChild(QObject, "browserSubstituteDesc").setProperty('text', _("The browser used to launch this application is no longer compatible."))
                self.errorwnd.findChild(QObject, "getStoreBrowserBtn").setProperty('visible', False)
            else:
                self.errorwnd.findChild(QObject, "browserSubstituteTitle").setProperty('text', _("{0} was chosen for {1}").format(variables.sources[self.browsertype][self.browser]["name"], self.info["name"]))
                self.errorwnd.findChild(QObject, "browserSubstituteDesc").setProperty('text', _("Would you like to install {0} to allow {1} to run?").format(variables.sources[self.browsertype][self.browser]["name"], self.info["name"]))
                self.errorwnd.findChild(QObject, "getStoreBrowserBtn").setProperty('text', _("View %s in Store... (dummy)") % variables.sources[self.browsertype][self.browser]["name"])
                self.errorwnd.findChild(QObject, "getStoreBrowserBtn").setProperty('visible', os.path.isfile("/usr/bin/feren-store"))

    def websiteUnavailableError(self, perma=False, announcement=""):
        #FIXME: Currently goes unused (would this even be feasible, now it's DC'd from Store?)
        self.openErrorWindow()

        #perma: Is the website permanently dead?
        #announcement: Link to the announcement - used if perma is True
        pass #TODO


    #Automatic Profile Loading
    def autoProfileLoad(self):
        #Don't autoload if overridden or there is no configured profile
        if "--force-manager" in sys.argv or self.autoload == "":
            return
        self.openProfile(self.autoload, True, True)
        sys.exit(0) #End the code here

    def getAutoProfileLoad(self):
        result = ""
        #Shortened name to make the multiple times the code uses it shorter too
        solauto = "%s/.solstice-autolaunch" % self.profilesdir
        if not os.path.isfile(solauto):
            return ""
        with open(solauto, 'r') as fp:
            result = fp.readline()
        if not os.path.isdir(utils.get_profilepath(self.info["id"], result)):
            return ""
        return result

    def setAutoProfileLoad(self, value):
        solauto = "%s/.solstice-autolaunch" % self.profilesdir
        if value == "" and os.path.isfile(solauto):
            try:
                os.remove(solauto)
            except Exception as e:
                raise SolsticeGUIException(_("Could not disable automatic profile launching: %s") % e)
            return #Prevent code after this
        elif value == "":
            return #from running if ""
        #Shortened name to make the multiple times the code uses it shorter too
        try:
            with open(solauto, 'w') as fp:
                fp.write(value)
        except Exception as e:
            raise SolsticeGUIException(_("Could not configure automatic profile launching: %s") % e)


    #Profile(s) Checks
    def refreshProfilesList(self):
        if not os.path.isdir(self.profilesdir):
            self.profilesmodel.setData([])
            return
        profiles = []
        for i in os.listdir(self.profilesdir):
            if os.path.isdir(self.profilesdir + "/" + i):
                if os.path.isfile(self.profilesdir + "/" + i + variables.sources[self.browsertype][self.browser]["expected-file"]):
                    readablename = i
                    if os.path.isfile(self.profilesdir + "/" + i + "/.solstice-settings"):
                        with open(self.profilesdir + "/" + i + "/.solstice-settings", 'r') as fp:
                            solsettings = json.loads(fp.read())
                            if "readablename" in solsettings:
                                readablename = solsettings["readablename"]
                    profiles.append({"pname": readablename, "profileid": i})
        #Refresh profiles list in profilesmodel
        self.profilesmodel.setData(profiles)


    #Profile management
    def saveProfile(self):
        newname = self.mainwnd.findChild(QObject, "editProfileName").property('text')
        if newname == "":
            self.mainwnd.findChild(QObject, "editProfileNameError").setProperty('text', _("Please enter a name for this profile"))
            return

        darkmode = self.mainwnd.findChild(QObject, "forceDarkMode").property('checked')
        nocache = self.mainwnd.findChild(QObject, "noCache").property('checked')
        try:
            if self.lastedited == "": #New profile
                profileid = utils.profileid_generate(self.profilesdir, self.mainwnd.findChild(QObject, "editProfileName").property('text'))
                #'Update' profile to give it its initial configurations
                self.main.update_profile(self.info, newname, profileid, darkmode, nocache)
            else:
                outdated = utils.get_profile_outdated(self.lastedited, self.info["id"], self.info["lastupdated"], self.browser)
                self.main.batch_set_profilesettings(self.browsertype, utils.get_profilepath(self.info["id"], self.lastedited), self.info["name"], newname, outdated, darkmode, nocache)
        except Exception as e:
            self.mainwnd.findChild(QObject, "editProfileNameError").setProperty('text', _("Failed to save changes"))
            print(e)
            return

        self.mainwnd.findChild(QObject, "editProfileNameError").setProperty('text', _(""))
        if self.lastedited == "":
            #Automatically launch newly created profile
            self.openProfile(profileid, False)
        else:
            #Refresh profiles list and return to profile manager
            self.refreshProfilesList()
            self.gotoManager()
        del self.lastedited #delete the variable as it is now redundant

    def gotoProfileEditor(self, newprofile, profileid=""):
        self.lastedited = profileid
        self.mainwnd.findChild(QObject, "editProfileNameError").setProperty('text', _(""))
        if newprofile == True:
            self.mainwnd.findChild(QObject, "editProfileHeader").setProperty('text', _("Create a profile"))
            self.mainwnd.findChild(QObject, "deleteProfileBtn").setProperty('enabled', False)
            self.mainwnd.findChild(QObject, "editProfileName").setProperty('text', "")
            self.mainwnd.findChild(QObject, "forceDarkMode").setProperty('checked', False)
            self.mainwnd.findChild(QObject, "noCache").setProperty('checked', False)
        else:
            profilename, nocache, darkmode = utils.get_profile_settings(self.info["id"], profileid) #Getting necessary values
            self.mainwnd.findChild(QObject, "editProfileHeader").setProperty('text', _("Configuring %s") % profilename)
            self.mainwnd.findChild(QObject, "deleteProfileBtn").setProperty('enabled', True)
            self.mainwnd.findChild(QObject, "editProfileName").setProperty('text', profilename)
            self.mainwnd.findChild(QObject, "forceDarkMode").setProperty('checked', darkmode)
            self.mainwnd.findChild(QObject, "noCache").setProperty('checked', nocache)
        self.mainwnd.findChild(QObject, "pages").setProperty('currentIndex', 2)
        self.mainwnd.findChild(QObject, "editProfileName").forceActiveFocus(True)

    def updateProfile(self, profileid):
        profilename, nocache, darkmode = utils.get_profile_settings(self.info["id"], profileid) #Getting necessary values
        self.main.update_profile(self.info, profilename, profileid, darkmode, nocache)

    def gotoProfiles(self):
        if self.profilesmodel.profiles == []: #Jump to profile creator if there are no profiles
            self.gotoProfileEditor(True)
        else:
            self.mainwnd.findChild(QObject, "pages").setProperty('currentIndex', 0)
            self.mainwnd.findChild(QObject, "profileSelect").forceActiveFocus(True)

    def gotoManager(self):
        if self.profilesmodel.profiles == []: #Jump to profile creator if there are no profiles
            self.gotoProfileEditor(True)
        else:
            self.mainwnd.findChild(QObject, "pages").setProperty('currentIndex', 1)
            self.mainwnd.findChild(QObject, "profileManager").forceActiveFocus(True)

    def deleteProfile(self):
        #The only time we can press this button is inside the Editor.
        #Therefore, since self.lastedited exists during such times, we can use it for the profile ID
        self.main.delete_profile(self.info, self.lastedited)

        self.refreshProfilesList()
        self.gotoManager()


    #Run profile
    def openProfile(self, profileid, alwaysuse, auto=False):
        #Set autostart if alwaysuse is True
        if auto == False: #Don't change autoload if autoloading
            if alwaysuse == True and self.autoload != profileid: #Reducing file-writes
                self.setAutoProfileLoad(profileid)
            elif alwaysuse == False:
                self.setAutoProfileLoad("")

        #Check lastupdated of profile against shortcut's lastupdated
        if utils.get_profile_outdated(profileid, self.info["id"], self.info["lastupdated"], self.browser) == True:
            try:
                self.updateProfile(profileid) #Update the profile if the shortcut's outdated
            except Exception as e:
                if e.__class__.__name__ != "ProfileInUseException": #skip if profile's in use
                    print(_("Failed to update profile: %s") % e)
                    self.genericError(_("Failed to update profile - %s") % self.info["name"], _("Failed to update profile"), _("An error occurred when trying to update this profile.\nPlease view the 'solstice' logs in ~/.xsession-errors and consider reporting this issue to Solstice's developers.\n\nThe application will now abort."))
                    return

        #Start the requested profile
        try:
            self.main.run_profile(self.info["id"], profileid, self.info["browser"], self.info["browsertype"], self.info["website"], self.info["wmclass"], self.info["nohistory"], self.closeCallback if not auto else None)
        except Exception as e:
            print(_("Failed to load profile: %s") % e)
            self.genericError(_("Failed to load profile - %s") % self.info["name"], _("Failed to load profile"), _("An error occurred when trying to load this profile.\nPlease view the 'solstice' logs in ~/.xsession-errors and consider reporting this issue to Solstice's developers.\n\nThe application will now abort."))
            return

        self.quit()

    #Callback to close mainwnd
    def closeCallback(self):
        self.mainwnd.close()

app = None
if not os.path.isfile(sys.argv[1]):
    sys.exit(2)
try:
    infoclass = DesktopFileInformation(sys.argv[1])
except Exception as e:
    print("Failed to load shortcut: %s" % e)
    app = SolsticeGUI({})
else:
    app = SolsticeGUI(infoclass.info)

sys.exit(app.exec())
